<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ant-quic Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-29e6057a.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-8afbb71c.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">ant-quic Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/dirvine/ant-quic" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the ant-quic documentation!</p>
<p>ant-quic is a QUIC transport protocol implementation with advanced NAT traversal capabilities, optimized for P2P networks and the Autonomi ecosystem. It provides sophisticated hole-punching protocols to achieve near 100% connectivity through restrictive NATs, with 100% Post-Quantum Cryptography security.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>Symmetric P2P Architecture</strong>: Every node is equal - no special client/server/bootstrap roles</li>
<li><strong>100% Post-Quantum Cryptography</strong>: ML-KEM-768 + ML-DSA-65 on every connection (always enabled)</li>
<li><strong>Advanced NAT Traversal</strong>: Implementation of draft-seemann-quic-nat-traversal-02</li>
<li><strong>Address Discovery</strong>: Native QUIC address discovery (draft-ietf-quic-address-discovery-00)</li>
<li><strong>Raw Public Keys</strong>: Ed25519 identity via RFC 7250 (no certificates required)</li>
<li><strong>High Performance</strong>: Built on top of the battle-tested Quinn QUIC implementation</li>
<li><strong>Cross-Platform</strong>: Supports Windows, Linux, and macOS</li>
<li><strong>Production Ready</strong>: Comprehensive test suite with 580+ tests</li>
</ul>
<h2 id="symmetric-p2p-model"><a class="header" href="#symmetric-p2p-model">Symmetric P2P Model</a></h2>
<p>In ant-quic v0.13.0+, <strong>all nodes are symmetric</strong>. Every node can:</p>
<ul>
<li>Initiate connections to other nodes</li>
<li>Accept incoming connections</li>
<li>Observe external addresses of connecting peers</li>
<li>Coordinate NAT traversal for other peers</li>
<li>Relay traffic when direct connection fails</li>
</ul>
<p>There are no special “bootstrap nodes”, “coordinators”, or “servers” - just peers with different network positions (some have public IPs, some are behind NAT).</p>
<h2 id="post-quantum-security"><a class="header" href="#post-quantum-security">Post-Quantum Security</a></h2>
<p>Every connection uses hybrid cryptography:</p>
<ul>
<li><strong>Key Exchange</strong>: X25519 + ML-KEM-768</li>
<li><strong>Signatures</strong>: Ed25519 + ML-DSA-65</li>
</ul>
<p>This protects against both current classical attacks and future quantum computer threats. PQC cannot be disabled - it’s always on in v0.13.0+.</p>
<h2 id="who-is-this-for"><a class="header" href="#who-is-this-for">Who is this for?</a></h2>
<ul>
<li><strong>P2P Application Developers</strong>: Build decentralized applications with reliable connectivity</li>
<li><strong>Network Engineers</strong>: Deploy QUIC-based services with NAT traversal</li>
<li><strong>Security-Conscious Developers</strong>: Applications requiring post-quantum security</li>
<li><strong>Researchers</strong>: Experiment with modern transport protocols</li>
</ul>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ul>
<li><a href="https://github.com/dirvine/ant-quic/issues">GitHub Issues</a></li>
<li><a href="https://docs.rs/ant-quic">API Documentation</a></li>
<li><a href="https://github.com/dirvine/ant-quic/tree/master/examples">Examples</a></li>
</ul>
<h2 id="protocol-standards"><a class="header" href="#protocol-standards">Protocol Standards</a></h2>
<p>ant-quic implements these standards:</p>
<ul>
<li><a href="https://www.rfc-editor.org/rfc/rfc9000">RFC 9000</a> - QUIC Transport Protocol</li>
<li><a href="https://www.rfc-editor.org/rfc/rfc7250">RFC 7250</a> - Raw Public Keys in TLS</li>
<li><a href="../../rfcs/draft-seemann-quic-nat-traversal-02.txt">draft-seemann-quic-nat-traversal-02</a> - QUIC NAT Traversal</li>
<li><a href="../../rfcs/draft-ietf-quic-address-discovery-00.txt">draft-ietf-quic-address-discovery-00</a> - Address Discovery</li>
<li><a href="../../rfcs/fips-203-ml-kem.pdf">FIPS 203</a> - ML-KEM Key Encapsulation</li>
<li><a href="../../rfcs/fips-204-ml-dsa.pdf">FIPS 204</a> - ML-DSA Digital Signatures</li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>ant-quic is dual-licensed under MIT and Apache 2.0.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This guide will help you get started with ant-quic v0.13.0+.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>Rust 1.85.0 or later</li>
<li>Basic understanding of networking concepts</li>
<li>Familiarity with async Rust programming</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Add ant-quic to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
ant-quic = "0.13"
tokio = { version = "1", features = ["full"] }
</code></pre>
<h2 id="understanding-the-symmetric-p2p-model"><a class="header" href="#understanding-the-symmetric-p2p-model">Understanding the Symmetric P2P Model</a></h2>
<p>In ant-quic v0.13.0+, <strong>all nodes are symmetric</strong>. There are no special roles - every node can:</p>
<ul>
<li><strong>Initiate connections</strong> to other nodes</li>
<li><strong>Accept connections</strong> from other nodes</li>
<li><strong>Observe external addresses</strong> of connecting peers</li>
<li><strong>Coordinate NAT traversal</strong> for other peers</li>
</ul>
<p>This means there’s no distinction between “client” and “server” - your application is both.</p>
<h2 id="your-first-ant-quic-application"><a class="header" href="#your-first-ant-quic-application">Your First ant-quic Application</a></h2>
<p>Here’s a simple example that creates a P2P endpoint:</p>
<pre class="playground"><code class="language-rust">use ant_quic::{P2pEndpoint, P2pConfig, P2pEvent};
use std::time::Duration;

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    // Configure the endpoint
    let config = P2pConfig::builder()
        .known_peer("quic.saorsalabs.com:9000".parse()?)
        .build()?;

    // Create the endpoint
    let endpoint = P2pEndpoint::new(config).await?;

    println!("Peer ID: {}", endpoint.peer_id().to_hex());

    // Discover external address through known peers
    endpoint.connect_bootstrap().await?;

    if let Some(addr) = endpoint.external_address() {
        println!("External address: {}", addr);
    }

    // Handle incoming connections
    while let Some(conn) = endpoint.accept().await {
        println!("New connection from peer");
        tokio::spawn(async move {
            // Handle the connection
            if let Ok((mut send, mut recv)) = conn.accept_bi().await {
                if let Ok(data) = recv.read_to_end(4096).await {
                    println!("Received: {}", String::from_utf8_lossy(&amp;data));
                }
            }
        });
    }

    Ok(())
}</code></pre>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<h3 id="known-peers"><a class="header" href="#known-peers">Known Peers</a></h3>
<p>Known peers are simply addresses to connect to first for address discovery. Unlike “bootstrap nodes” in other systems, known peers are not special infrastructure - they’re just regular peers with known addresses.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = P2pConfig::builder()
    .known_peer("peer1.example.com:9000".parse()?)
    .known_peer("peer2.example.com:9000".parse()?)
    .build()?;
<span class="boring">}</span></code></pre>
<h3 id="address-discovery"><a class="header" href="#address-discovery">Address Discovery</a></h3>
<p>When you connect to a known peer, they observe your external address and report it back to you via OBSERVED_ADDRESS frames. This works without STUN servers - it’s built into the QUIC protocol.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Connect to known peers and discover external address
endpoint.connect_bootstrap().await?;

// Now you know how others see you
let external = endpoint.external_address();
<span class="boring">}</span></code></pre>
<h3 id="events"><a class="header" href="#events">Events</a></h3>
<p>Subscribe to events to monitor your endpoint:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut events = endpoint.subscribe();
while let Ok(event) = events.recv().await {
    match event {
        P2pEvent::Connected { peer_id, addr } =&gt; {
            println!("Connected to {} at {}", peer_id.to_hex(), addr);
        }
        P2pEvent::AddressDiscovered { addr } =&gt; {
            println!("Discovered external address: {}", addr);
        }
        P2pEvent::HolePunchSucceeded { peer_id, addr } =&gt; {
            println!("Direct connection to {} via {}", peer_id.to_hex(), addr);
        }
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre>
<h2 id="security"><a class="header" href="#security">Security</a></h2>
<p>Every connection in ant-quic uses hybrid post-quantum cryptography:</p>
<ul>
<li><strong>Key Exchange</strong>: X25519 + ML-KEM-768</li>
<li><strong>Signatures</strong>: Ed25519 + ML-DSA-65</li>
</ul>
<p>This is always enabled - there’s no way to disable PQC. Your communications are protected against both current and future quantum attacks.</p>
<h2 id="whats-not-in-ant-quic-v0130"><a class="header" href="#whats-not-in-ant-quic-v0130">What’s NOT in ant-quic v0.13.0</a></h2>
<p>The following concepts were <strong>removed</strong> in v0.13.0:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Removed</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>EndpointRole::Client/Server/Bootstrap</code></td><td>All nodes are symmetric</td></tr>
<tr><td><code>PqcMode</code></td><td>PQC is always on</td></tr>
<tr><td><code>HybridPreference</code></td><td>No mode selection</td></tr>
<tr><td>Bootstrap nodes as special infrastructure</td><td>All peers are equal</td></tr>
</tbody>
</table>
</div>
<p>If you’re migrating from an earlier version, see the <a href="../guides/pqc-migration.html">migration guide</a>.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="#installation-1">Installation</a> - Detailed installation instructions</li>
<li><a href="#quick-start">Quick Start</a> - Build a complete P2P application</li>
<li><a href="#configuration">Configuration</a> - All configuration options</li>
<li><a href="#examples">Examples</a> - Explore more complex examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installation-1"><a class="header" href="#installation-1">Installation</a></h1>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<h3 id="minimum-rust-version"><a class="header" href="#minimum-rust-version">Minimum Rust Version</a></h3>
<p>ant-quic requires <strong>Rust 1.85.0</strong> or later (Rust Edition 2024).</p>
<h3 id="platform-requirements"><a class="header" href="#platform-requirements">Platform Requirements</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Requirements</th></tr>
</thead>
<tbody>
<tr><td>Linux</td><td>glibc 2.17+, kernel 3.10+</td></tr>
<tr><td>Windows</td><td>Windows 10+</td></tr>
<tr><td>macOS</td><td>macOS 10.13+</td></tr>
<tr><td>Android</td><td>API level 21+</td></tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: WASM is not supported. ant-quic uses raw UDP sockets and NAT traversal which are incompatible with the browser sandbox environment.</p>
<h2 id="installing-from-cratesio"><a class="header" href="#installing-from-cratesio">Installing from crates.io</a></h2>
<p>Add ant-quic to your project:</p>
<pre><code class="language-bash">cargo add ant-quic
</code></pre>
<p>Or manually add to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
ant-quic = "0.13"
tokio = { version = "1", features = ["full"] }
</code></pre>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h2>
<p>ant-quic supports various feature flags:</p>
<h3 id="cryptography-providers"><a class="header" href="#cryptography-providers">Cryptography Providers</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>rustls-ring</code></td><td>Use ring for cryptography (default)</td></tr>
<tr><td><code>rustls-aws-lc-rs</code></td><td>Use AWS-LC for cryptography (recommended for PQC)</td></tr>
</tbody>
</table>
</div>
<h3 id="development-features"><a class="header" href="#development-features">Development Features</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>trace</code></td><td>Enable tracing functionality</td></tr>
<tr><td><code>test-utils</code></td><td>Testing utilities</td></tr>
</tbody>
</table>
</div>
<h3 id="example-configurations"><a class="header" href="#example-configurations">Example Configurations</a></h3>
<pre><code class="language-toml"># Default (ring crypto)
[dependencies]
ant-quic = "0.13"

# AWS-LC crypto (better PQC performance)
[dependencies]
ant-quic = { version = "0.13", default-features = false, features = ["rustls-aws-lc-rs"] }

# With tracing
[dependencies]
ant-quic = { version = "0.13", features = ["trace"] }
</code></pre>
<h2 id="post-quantum-cryptography"><a class="header" href="#post-quantum-cryptography">Post-Quantum Cryptography</a></h2>
<p>PQC is <strong>always enabled</strong> in ant-quic v0.13.0+. Every connection uses:</p>
<ul>
<li><strong>ML-KEM-768</strong> for key encapsulation (FIPS 203)</li>
<li><strong>ML-DSA-65</strong> for digital signatures (FIPS 204)</li>
</ul>
<p>These are combined with classical algorithms (X25519, Ed25519) in a hybrid scheme. There is no way to disable PQC.</p>
<h3 id="pqc-performance-considerations"><a class="header" href="#pqc-performance-considerations">PQC Performance Considerations</a></h3>
<p>PQC algorithms have larger key and signature sizes:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Classical</th><th>Post-Quantum</th></tr>
</thead>
<tbody>
<tr><td>Public Key (KEM)</td><td>32 bytes</td><td>1,184 bytes</td></tr>
<tr><td>Ciphertext</td><td>32 bytes</td><td>1,088 bytes</td></tr>
<tr><td>Public Key (Sig)</td><td>32 bytes</td><td>1,952 bytes</td></tr>
<tr><td>Signature</td><td>64 bytes</td><td>3,293 bytes</td></tr>
</tbody>
</table>
</div>
<p>This affects handshake size and latency. The <code>aws-lc-rs</code> feature provides optimized implementations.</p>
<h2 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h2>
<pre><code class="language-bash">git clone https://github.com/dirvine/ant-quic
cd ant-quic
cargo build --release
</code></pre>
<h3 id="development-build"><a class="header" href="#development-build">Development Build</a></h3>
<pre><code class="language-bash"># Quick build for development
cargo build

# Build with all checks
cargo fmt --all
cargo clippy --all-targets -- -D warnings
cargo test
</code></pre>
<h2 id="running-the-binary"><a class="header" href="#running-the-binary">Running the Binary</a></h2>
<p>ant-quic includes a binary for P2P networking:</p>
<pre><code class="language-bash"># Show help
cargo run --bin ant-quic -- --help

# Start a node
cargo run --bin ant-quic -- --listen 0.0.0.0:9000

# Connect to known peers
cargo run --bin ant-quic -- --bootstrap quic.saorsalabs.com:9000

# Run with dashboard
cargo run --bin ant-quic -- --dashboard --listen 0.0.0.0:9000
</code></pre>
<h2 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying Installation</a></h2>
<p>Create a test file to verify everything works:</p>
<pre class="playground"><code class="language-rust">// src/main.rs
use ant_quic::{P2pEndpoint, P2pConfig};

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    let config = P2pConfig::builder().build()?;
    let endpoint = P2pEndpoint::new(config).await?;

    println!("ant-quic v0.13.0 installed successfully!");
    println!("Peer ID: {}", endpoint.peer_id().to_hex());

    Ok(())
}</code></pre>
<p>Run:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<h2 id="troubleshooting-installation"><a class="header" href="#troubleshooting-installation">Troubleshooting Installation</a></h2>
<h3 id="crypto-provider-conflicts"><a class="header" href="#crypto-provider-conflicts">Crypto Provider Conflicts</a></h3>
<p>If you get errors about multiple crypto providers:</p>
<pre><code class="language-toml"># Use only one crypto backend
ant-quic = { version = "0.13", default-features = false, features = ["rustls-aws-lc-rs"] }
</code></pre>
<h3 id="aws-lc-build-failures"><a class="header" href="#aws-lc-build-failures">AWS-LC Build Failures</a></h3>
<p>AWS-LC requires a C compiler and CMake. Install them:</p>
<pre><code class="language-bash"># Ubuntu/Debian
sudo apt install build-essential cmake

# macOS
xcode-select --install
brew install cmake

# Windows
# Install Visual Studio Build Tools and CMake
</code></pre>
<h3 id="link-errors"><a class="header" href="#link-errors">Link Errors</a></h3>
<p>If you see link errors with ring:</p>
<pre><code class="language-bash"># Clear build cache
cargo clean
cargo build
</code></pre>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="#getting-started">Getting Started</a> - First steps with ant-quic</li>
<li><a href="#quick-start">Quick Start</a> - Build your first application</li>
<li><a href="#platform-support">Platform Support</a> - Detailed platform information</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>Let’s build a simple P2P application using ant-quic v0.13.0+.</p>
<h2 id="create-a-new-project"><a class="header" href="#create-a-new-project">Create a New Project</a></h2>
<pre><code class="language-bash">cargo new ant-quic-demo
cd ant-quic-demo
</code></pre>
<h2 id="add-dependencies"><a class="header" href="#add-dependencies">Add Dependencies</a></h2>
<p>Edit <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
ant-quic = "0.13"
tokio = { version = "1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = "0.3"
anyhow = "1.0"
</code></pre>
<h2 id="basic-p2p-application"><a class="header" href="#basic-p2p-application">Basic P2P Application</a></h2>
<p>Create <code>src/main.rs</code>:</p>
<pre class="playground"><code class="language-rust">use ant_quic::{P2pEndpoint, P2pConfig, P2pEvent, NatConfig};
use std::time::Duration;
use tracing::info;

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    // Initialize logging
    tracing_subscriber::fmt::init();

    // Configure the P2P endpoint
    // All nodes are symmetric - no roles to configure!
    let config = P2pConfig::builder()
        // Known peers to connect to first for address discovery
        .known_peer("quic.saorsalabs.com:9000".parse()?)
        // NAT traversal tuning (optional - sensible defaults provided)
        .nat(NatConfig {
            max_candidates: 10,
            coordination_timeout: Duration::from_secs(15),
            discovery_timeout: Duration::from_secs(5),
            enable_symmetric_nat: true,
            ..Default::default()
        })
        .build()?;

    // Create the endpoint
    let endpoint = P2pEndpoint::new(config).await?;
    info!("Node started with peer ID: {:?}", endpoint.peer_id());

    // Connect to known peers and discover our external address
    endpoint.connect_bootstrap().await?;

    // Check what address others see us as
    if let Some(addr) = endpoint.external_address() {
        info!("Our external address: {}", addr);
    }

    // Subscribe to P2P events
    let mut events = endpoint.subscribe();

    // Spawn event handler
    tokio::spawn(async move {
        while let Ok(event) = events.recv().await {
            match event {
                P2pEvent::Connected { peer_id, addr } =&gt; {
                    info!("Connected to {} at {}", peer_id.to_hex(), addr);
                }
                P2pEvent::Disconnected { peer_id, reason } =&gt; {
                    info!("Disconnected from {}: {}", peer_id.to_hex(), reason);
                }
                P2pEvent::AddressDiscovered { addr } =&gt; {
                    info!("Discovered external address: {}", addr);
                }
                P2pEvent::HolePunchSucceeded { peer_id, addr } =&gt; {
                    info!("Direct connection to {} via {}", peer_id.to_hex(), addr);
                }
                _ =&gt; {}
            }
        }
    });

    // Keep the application running
    tokio::signal::ctrl_c().await?;
    info!("Shutting down...");

    Ok(())
}</code></pre>
<h2 id="running-the-application"><a class="header" href="#running-the-application">Running the Application</a></h2>
<pre><code class="language-bash"># Run the node
cargo run
</code></pre>
<p>Since all nodes are symmetric, there’s no separate “server” or “client” mode. Every node can both connect to others and accept connections.</p>
<h2 id="connecting-to-a-specific-peer"><a class="header" href="#connecting-to-a-specific-peer">Connecting to a Specific Peer</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Connect to a peer by address
let target = "192.168.1.100:9000".parse()?;
let connection = endpoint.connect(target).await?;

// Open a bidirectional stream
let (mut send, mut recv) = connection.open_bi().await?;

// Send data
send.write_all(b"Hello, peer!").await?;
send.finish()?;

// Receive response
let response = recv.read_to_end(1024).await?;
println!("Response: {:?}", response);
<span class="boring">}</span></code></pre>
<h2 id="accepting-connections"><a class="header" href="#accepting-connections">Accepting Connections</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Accept incoming connections (all nodes can do this!)
while let Some(conn) = endpoint.accept().await {
    tokio::spawn(async move {
        // Handle the connection
        if let Ok(stream) = conn.accept_bi().await {
            let (send, mut recv) = stream;
            // Process incoming data
            let data = recv.read_to_end(4096).await.unwrap_or_default();
            println!("Received: {:?}", data);
        }
    });
}
<span class="boring">}</span></code></pre>
<h2 id="key-concepts-1"><a class="header" href="#key-concepts-1">Key Concepts</a></h2>
<ol>
<li><strong>Symmetric P2P</strong>: Every node is identical - no roles, no special infrastructure</li>
<li><strong>Known Peers</strong>: Addresses to connect to first for address discovery (not “bootstrap nodes”)</li>
<li><strong>100% PQC</strong>: ML-KEM-768 + ML-DSA-65 on every connection (cannot be disabled)</li>
<li><strong>NAT Traversal</strong>: Automatic via QUIC protocol extensions</li>
<li><strong>Address Discovery</strong>: Learn your external address from peers via OBSERVED_ADDRESS frames</li>
</ol>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li><a href="#configuration">Configuration</a> - Learn about all configuration options</li>
<li><a href="#nat-traversal">NAT Traversal</a> - Understanding NAT traversal in depth</li>
<li><a href="#examples">Examples</a> - More complete examples</li>
<li><a href="#api-reference">API Reference</a> - Full API documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>ant-quic v0.13.0+ provides configuration through <code>P2pConfig</code> with a builder pattern.</p>
<h2 id="basic-configuration"><a class="header" href="#basic-configuration">Basic Configuration</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ant_quic::{P2pEndpoint, P2pConfig, NatConfig, PqcConfig, MtuConfig};
use std::time::Duration;

let config = P2pConfig::builder()
    // Known peers for address discovery
    .known_peer("peer1.example.com:9000".parse()?)
    .known_peer("peer2.example.com:9000".parse()?)
    // Bind address (optional)
    .bind_addr("0.0.0.0:9000".parse()?)
    // Connection limits
    .max_connections(100)
    .build()?;

let endpoint = P2pEndpoint::new(config).await?;
<span class="boring">}</span></code></pre>
<h2 id="p2pconfig-builder"><a class="header" href="#p2pconfig-builder">P2pConfig Builder</a></h2>
<p>All configuration is done through the builder pattern:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = P2pConfig::builder()
    // Network configuration
    .bind_addr("0.0.0.0:9000".parse()?)
    .known_peer("peer.example.com:9000".parse()?)

    // NAT traversal tuning
    .nat(NatConfig { ... })

    // PQC tuning (cannot disable PQC)
    .pqc(PqcConfig::builder().build()?)

    // MTU configuration
    .mtu(MtuConfig { ... })

    // Connection limits
    .max_connections(100)
    .connection_timeout(Duration::from_secs(30))
    .idle_timeout(Duration::from_secs(60))

    .build()?;
<span class="boring">}</span></code></pre>
<h2 id="symmetric-p2p-model-1"><a class="header" href="#symmetric-p2p-model-1">Symmetric P2P Model</a></h2>
<p>In v0.13.0+, there are <strong>no roles to configure</strong>. All nodes are symmetric:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// OLD (v0.12 and earlier) - DO NOT USE
// let config = QuicNodeConfig {
//     role: EndpointRole::Client,  // REMOVED
//     enable_coordinator: false,   // REMOVED
//     ...
// };

// NEW (v0.13.0+)
let config = P2pConfig::builder()
    .known_peer("peer.example.com:9000".parse()?)
    .build()?;

// Every node can both connect AND accept connections
<span class="boring">}</span></code></pre>
<h2 id="nat-traversal-configuration"><a class="header" href="#nat-traversal-configuration">NAT Traversal Configuration</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ant_quic::NatConfig;

let nat_config = NatConfig {
    // Maximum candidate addresses per peer
    max_candidates: 10,

    // Timeout for hole punch coordination
    coordination_timeout: Duration::from_secs(15),

    // Timeout for candidate discovery
    discovery_timeout: Duration::from_secs(5),

    // Enable port prediction for symmetric NAT
    enable_symmetric_nat: true,

    // Number of hole punch attempts
    hole_punch_retries: 5,

    ..Default::default()
};

let config = P2pConfig::builder()
    .nat(nat_config)
    .build()?;
<span class="boring">}</span></code></pre>
<h3 id="natconfig-parameters"><a class="header" href="#natconfig-parameters">NatConfig Parameters</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>max_candidates</code></td><td><code>usize</code></td><td><code>10</code></td><td>Maximum address candidates per peer</td></tr>
<tr><td><code>coordination_timeout</code></td><td><code>Duration</code></td><td><code>15s</code></td><td>Timeout for hole punch coordination</td></tr>
<tr><td><code>discovery_timeout</code></td><td><code>Duration</code></td><td><code>5s</code></td><td>Timeout for candidate discovery</td></tr>
<tr><td><code>enable_symmetric_nat</code></td><td><code>bool</code></td><td><code>true</code></td><td>Enable port prediction for symmetric NAT</td></tr>
<tr><td><code>hole_punch_retries</code></td><td><code>u32</code></td><td><code>5</code></td><td>Number of hole punch attempts</td></tr>
</tbody>
</table>
</div>
<h2 id="pqc-configuration"><a class="header" href="#pqc-configuration">PQC Configuration</a></h2>
<p>PQC is <strong>always enabled</strong> in v0.13.0+. Configuration is for tuning only:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ant_quic::PqcConfig;

let pqc_config = PqcConfig::builder()
    // Enable/disable specific algorithms (both default to true)
    .ml_kem(true)           // ML-KEM-768 for key encapsulation
    .ml_dsa(true)           // ML-DSA-65 for signatures

    // Memory pool for key operations
    .memory_pool_size(10)

    // Adjust handshake timeout for slower hardware
    .handshake_timeout_multiplier(1.5)
    .build()?;

let config = P2pConfig::builder()
    .pqc(pqc_config)
    .build()?;
<span class="boring">}</span></code></pre>
<h3 id="pqcconfig-parameters"><a class="header" href="#pqcconfig-parameters">PqcConfig Parameters</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>ml_kem</code></td><td><code>bool</code></td><td><code>true</code></td><td>Enable ML-KEM-768 key encapsulation</td></tr>
<tr><td><code>ml_dsa</code></td><td><code>bool</code></td><td><code>true</code></td><td>Enable ML-DSA-65 signatures</td></tr>
<tr><td><code>memory_pool_size</code></td><td><code>usize</code></td><td><code>10</code></td><td>Pre-allocated key operation buffers</td></tr>
<tr><td><code>handshake_timeout_multiplier</code></td><td><code>f64</code></td><td><code>1.0</code></td><td>Multiplier for handshake timeouts</td></tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: At least one of <code>ml_kem</code> or <code>ml_dsa</code> must be true. PQC cannot be completely disabled.</p>
<h2 id="mtu-configuration"><a class="header" href="#mtu-configuration">MTU Configuration</a></h2>
<p>Configure MTU for networks with PQC overhead:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ant_quic::MtuConfig;

let mtu_config = MtuConfig {
    initial: 1200,  // Conservative initial MTU
    min: 1200,      // Minimum MTU
    max: 1500,      // Maximum MTU
};

let config = P2pConfig::builder()
    .mtu(mtu_config)
    .build()?;
<span class="boring">}</span></code></pre>
<h3 id="mtu-considerations"><a class="header" href="#mtu-considerations">MTU Considerations</a></h3>
<p>PQC increases packet sizes:</p>
<ul>
<li>ML-KEM-768 public key: 1,184 bytes</li>
<li>ML-KEM-768 ciphertext: 1,088 bytes</li>
<li>ML-DSA-65 signature: 3,293 bytes</li>
</ul>
<p>For constrained networks, use conservative MTU settings.</p>
<h2 id="connection-settings"><a class="header" href="#connection-settings">Connection Settings</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = P2pConfig::builder()
    // Maximum concurrent connections
    .max_connections(100)

    // Connection establishment timeout
    .connection_timeout(Duration::from_secs(30))

    // Idle timeout before closing connection
    .idle_timeout(Duration::from_secs(60))

    .build()?;
<span class="boring">}</span></code></pre>
<h2 id="known-peers-1"><a class="header" href="#known-peers-1">Known Peers</a></h2>
<p>Known peers are addresses you connect to first for address discovery:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = P2pConfig::builder()
    // Add multiple known peers for redundancy
    .known_peer("us-east.example.com:9000".parse()?)
    .known_peer("eu-west.example.com:9000".parse()?)
    .known_peer("asia.example.com:9000".parse()?)
    .build()?;

// Connect to known peers and discover external address
endpoint.connect_bootstrap().await?;

// Check discovered address
if let Some(addr) = endpoint.external_address() {
    println!("External address: {}", addr);
}
<span class="boring">}</span></code></pre>
<p><strong>Best Practice</strong>: Use at least 3 known peers in different geographic regions.</p>
<h2 id="configuration-removed-in-v0130"><a class="header" href="#configuration-removed-in-v0130">Configuration Removed in v0.13.0</a></h2>
<p>The following configuration options were <strong>removed</strong> in v0.13.0:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Removed</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>EndpointRole</code></td><td>All nodes are symmetric</td></tr>
<tr><td><code>NatTraversalRole</code></td><td>All nodes are symmetric</td></tr>
<tr><td><code>PqcMode</code></td><td>PQC is always enabled</td></tr>
<tr><td><code>HybridPreference</code></td><td>No hybrid mode selection</td></tr>
<tr><td><code>fallback_enabled</code></td><td>No classical-only fallback</td></tr>
<tr><td><code>enable_coordinator</code></td><td>All nodes can coordinate</td></tr>
<tr><td><code>bootstrap_nodes</code></td><td>Replaced by <code>known_peer()</code></td></tr>
</tbody>
</table>
</div>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<p>Some settings can be configured via environment:</p>
<pre><code class="language-bash"># Logging
RUST_LOG=ant_quic=debug cargo run

# Specific modules
RUST_LOG=ant_quic::crypto::pqc=trace cargo run
</code></pre>
<h2 id="full-example"><a class="header" href="#full-example">Full Example</a></h2>
<pre class="playground"><code class="language-rust">use ant_quic::{P2pEndpoint, P2pConfig, NatConfig, PqcConfig, MtuConfig};
use std::time::Duration;

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    let config = P2pConfig::builder()
        // Network
        .bind_addr("0.0.0.0:9000".parse()?)
        .known_peer("quic.saorsalabs.com:9000".parse()?)

        // NAT traversal
        .nat(NatConfig {
            max_candidates: 10,
            coordination_timeout: Duration::from_secs(15),
            discovery_timeout: Duration::from_secs(5),
            enable_symmetric_nat: true,
            hole_punch_retries: 5,
            ..Default::default()
        })

        // PQC tuning
        .pqc(PqcConfig::builder()
            .ml_kem(true)
            .ml_dsa(true)
            .memory_pool_size(10)
            .build()?)

        // MTU
        .mtu(MtuConfig {
            initial: 1200,
            min: 1200,
            max: 1500,
        })

        // Connections
        .max_connections(100)
        .connection_timeout(Duration::from_secs(30))
        .idle_timeout(Duration::from_secs(60))

        .build()?;

    let endpoint = P2pEndpoint::new(config).await?;

    // Discover external address
    endpoint.connect_bootstrap().await?;

    Ok(())
}</code></pre>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See Also</a></h2>
<ul>
<li><a href="#quick-start">Quick Start</a></li>
<li><a href="#nat-traversal">NAT Traversal</a></li>
<li><a href="#security-1">Security</a></li>
<li><a href="#configuration-reference">Configuration Reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>ant-quic comes with several example applications demonstrating various features.</p>
<h2 id="running-examples"><a class="header" href="#running-examples">Running Examples</a></h2>
<p>All examples are in the <code>examples/</code> directory:</p>
<pre><code class="language-bash"># Simple chat application
cargo run --example simple_chat

# Chat demo with full features
cargo run --example chat_demo

# Dashboard demo
cargo run --example dashboard_demo

# PQC demo
cargo run --example pqc_demo
</code></pre>
<h2 id="simple-p2p-node"><a class="header" href="#simple-p2p-node">Simple P2P Node</a></h2>
<p>The simplest example showing basic P2P communication with v0.13.0+ API:</p>
<pre class="playground"><code class="language-rust">use ant_quic::{P2pEndpoint, P2pConfig, P2pEvent};
use std::time::Duration;

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    // Configure endpoint - all nodes are symmetric
    let config = P2pConfig::builder()
        .known_peer("quic.saorsalabs.com:9000".parse()?)
        .build()?;

    // Create endpoint
    let endpoint = P2pEndpoint::new(config).await?;
    println!("Peer ID: {}", endpoint.peer_id().to_hex());

    // Discover external address
    endpoint.connect_bootstrap().await?;
    if let Some(addr) = endpoint.external_address() {
        println!("External address: {}", addr);
    }

    // Handle events
    let mut events = endpoint.subscribe();
    while let Ok(event) = events.recv().await {
        match event {
            P2pEvent::Connected { peer_id, addr } =&gt; {
                println!("Connected: {} at {}", peer_id.to_hex(), addr);
            }
            P2pEvent::AddressDiscovered { addr } =&gt; {
                println!("Discovered: {}", addr);
            }
            _ =&gt; {}
        }
    }

    Ok(())
}</code></pre>
<h2 id="chat-application"><a class="header" href="#chat-application">Chat Application</a></h2>
<p>A complete chat application with message handling:</p>
<pre class="playground"><code class="language-rust">use ant_quic::{P2pEndpoint, P2pConfig, P2pEvent};
use tokio::io::{AsyncBufReadExt, BufReader};

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    let config = P2pConfig::builder()
        .known_peer("quic.saorsalabs.com:9000".parse()?)
        .build()?;

    let endpoint = P2pEndpoint::new(config).await?;
    endpoint.connect_bootstrap().await?;

    println!("Chat started. Peer ID: {}", endpoint.peer_id().to_hex());
    println!("Enter peer address to connect, or type messages:");

    // Handle incoming connections
    let endpoint_clone = endpoint.clone();
    tokio::spawn(async move {
        while let Some(conn) = endpoint_clone.accept().await {
            tokio::spawn(async move {
                if let Ok((_, mut recv)) = conn.accept_bi().await {
                    if let Ok(data) = recv.read_to_end(4096).await {
                        let msg = String::from_utf8_lossy(&amp;data);
                        println!("Received: {}", msg);
                    }
                }
            });
        }
    });

    // Handle user input
    let stdin = BufReader::new(tokio::io::stdin());
    let mut lines = stdin.lines();

    let mut current_conn = None;

    while let Ok(Some(line)) = lines.next_line().await {
        if line.starts_with("/connect ") {
            let addr = line[9..].parse()?;
            current_conn = Some(endpoint.connect(addr).await?);
            println!("Connected!");
        } else if let Some(conn) = &amp;current_conn {
            let (mut send, _) = conn.open_bi().await?;
            send.write_all(line.as_bytes()).await?;
            send.finish()?;
            println!("Sent: {}", line);
        }
    }

    Ok(())
}</code></pre>
<h2 id="nat-traversal-demo"><a class="header" href="#nat-traversal-demo">NAT Traversal Demo</a></h2>
<p>Demonstrates NAT traversal between nodes behind different NATs:</p>
<pre class="playground"><code class="language-rust">use ant_quic::{P2pEndpoint, P2pConfig, P2pEvent, NatConfig};
use std::time::Duration;

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    // Configure with NAT traversal tuning
    let config = P2pConfig::builder()
        .known_peer("quic.saorsalabs.com:9000".parse()?)
        .nat(NatConfig {
            max_candidates: 10,
            coordination_timeout: Duration::from_secs(15),
            enable_symmetric_nat: true,
            ..Default::default()
        })
        .build()?;

    let endpoint = P2pEndpoint::new(config).await?;

    // Discover external address
    endpoint.connect_bootstrap().await?;
    println!("External: {:?}", endpoint.external_address());

    // Show candidates
    let candidates = endpoint.get_local_candidates();
    println!("Candidates:");
    for c in candidates {
        println!("  {} from {:?}", c.addr, c.source);
    }

    // Monitor NAT traversal events
    let mut events = endpoint.subscribe();
    while let Ok(event) = events.recv().await {
        match event {
            P2pEvent::HolePunchStarted { peer_id } =&gt; {
                println!("Hole punching: {}", peer_id.to_hex());
            }
            P2pEvent::HolePunchSucceeded { peer_id, addr } =&gt; {
                println!("Direct connection: {} at {}", peer_id.to_hex(), addr);
            }
            P2pEvent::HolePunchFailed { peer_id, reason } =&gt; {
                println!("Failed: {} - {}", peer_id.to_hex(), reason);
            }
            _ =&gt; {}
        }
    }

    Ok(())
}</code></pre>
<h2 id="statistics-monitor"><a class="header" href="#statistics-monitor">Statistics Monitor</a></h2>
<p>Monitor endpoint statistics:</p>
<pre class="playground"><code class="language-rust">use ant_quic::{P2pEndpoint, P2pConfig};
use tokio::time::{interval, Duration};

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    let config = P2pConfig::builder()
        .known_peer("quic.saorsalabs.com:9000".parse()?)
        .build()?;

    let endpoint = P2pEndpoint::new(config).await?;
    endpoint.connect_bootstrap().await?;

    // Print statistics every 10 seconds
    let mut ticker = interval(Duration::from_secs(10));
    loop {
        ticker.tick().await;

        let stats = endpoint.stats();
        println!("=== Statistics ===");
        println!("Active connections: {}", stats.active_connections);
        println!("Discovered addresses: {}", stats.discovered_addresses);
        println!("Successful punches: {}", stats.successful_hole_punches);
        println!("Failed punches: {}", stats.failed_hole_punches);
        println!("Bytes sent: {}", stats.bytes_sent);
        println!("Bytes received: {}", stats.bytes_received);
    }
}</code></pre>
<h2 id="key-generation"><a class="header" href="#key-generation">Key Generation</a></h2>
<p>Generate and manage Ed25519 keys:</p>
<pre class="playground"><code class="language-rust">use ant_quic::key_utils::{generate_ed25519_keypair, derive_peer_id};

fn main() {
    // Generate a new keypair
    let (private_key, public_key) = generate_ed25519_keypair();

    // Derive peer ID
    let peer_id = derive_peer_id(&amp;public_key);

    println!("Generated new identity:");
    println!("  Peer ID: {}", peer_id.to_hex());
    println!("  Public key: {} bytes", public_key.len());

    // In a real application:
    // - Store private_key securely
    // - Share peer_id with trusted peers
}</code></pre>
<h2 id="running-the-examples"><a class="header" href="#running-the-examples">Running the Examples</a></h2>
<h3 id="terminal-setup"><a class="header" href="#terminal-setup">Terminal Setup</a></h3>
<pre><code class="language-bash"># Terminal 1: Start first node
cargo run --example simple_chat

# Terminal 2: Start second node and connect
cargo run --example simple_chat
# Then type: /connect &lt;address-from-terminal-1&gt;
</code></pre>
<h3 id="with-logging"><a class="header" href="#with-logging">With Logging</a></h3>
<pre><code class="language-bash"># Enable debug logging
RUST_LOG=ant_quic=debug cargo run --example simple_chat

# NAT traversal specific logging
RUST_LOG=ant_quic::nat_traversal=trace cargo run --example nat_demo

# PQC logging
RUST_LOG=ant_quic::crypto::pqc=debug cargo run --example pqc_demo
</code></pre>
<h2 id="key-changes-from-v012"><a class="header" href="#key-changes-from-v012">Key Changes from v0.12</a></h2>
<p>If you’re updating examples from earlier versions:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// OLD (v0.12 and earlier) - DO NOT USE
// let config = QuicNodeConfig {
//     role: EndpointRole::Client,
//     bootstrap_nodes: vec![...],
//     ...
// };
// let node = QuicP2PNode::new(config).await?;

// NEW (v0.13.0+)
let config = P2pConfig::builder()
    .known_peer("peer.example.com:9000".parse()?)
    .build()?;
let endpoint = P2pEndpoint::new(config).await?;
<span class="boring">}</span></code></pre>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See Also</a></h2>
<ul>
<li><a href="#quick-start">Quick Start</a></li>
<li><a href="#api-reference">API Reference</a></li>
<li><a href="#configuration">Configuration</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>ant-quic has a three-layer architecture designed for modularity and extensibility.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<pre><code>┌─────────────────────────────────────────┐
│         Applications (Layer 3)          │
│  ant-quic binary, examples, your apps   │
├─────────────────────────────────────────┤
│      Integration APIs (Layer 2)         │
│  P2pEndpoint, P2pConfig (Primary API)   │
├─────────────────────────────────────────┤
│   Protocol Implementation (Layer 1)     │
│  QUIC endpoints, connections, frames    │
│  PQC crypto, NAT traversal extensions   │
└─────────────────────────────────────────┘
</code></pre>
<h2 id="layer-1-protocol-implementation"><a class="header" href="#layer-1-protocol-implementation">Layer 1: Protocol Implementation</a></h2>
<p>The foundation layer implements the QUIC protocol with NAT traversal and PQC extensions:</p>
<ul>
<li><strong>Endpoint</strong> (<code>src/endpoint.rs</code>): Core QUIC endpoint management</li>
<li><strong>Connection</strong> (<code>src/connection/</code>): Connection state machine with NAT traversal</li>
<li><strong>Frames</strong> (<code>src/frame.rs</code>): QUIC frames including extension frames</li>
<li><strong>Crypto</strong> (<code>src/crypto/</code>): TLS, Raw Public Keys, and PQC support</li>
</ul>
<h3 id="protocol-extensions"><a class="header" href="#protocol-extensions">Protocol Extensions</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Extension</th><th>Standard</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>NAT Traversal</td><td>draft-seemann-quic-nat-traversal-02</td><td>Hole punching coordination</td></tr>
<tr><td>Address Discovery</td><td>draft-ietf-quic-address-discovery-00</td><td>External address detection</td></tr>
<tr><td>Raw Public Keys</td><td>RFC 7250</td><td>Certificate-free authentication</td></tr>
<tr><td>ML-KEM-768</td><td>FIPS 203</td><td>Post-quantum key encapsulation</td></tr>
<tr><td>ML-DSA-65</td><td>FIPS 204</td><td>Post-quantum digital signatures</td></tr>
</tbody>
</table>
</div>
<h2 id="layer-2-integration-apis"><a class="header" href="#layer-2-integration-apis">Layer 2: Integration APIs</a></h2>
<p>High-level APIs that make ant-quic easy to use:</p>
<ul>
<li><strong>P2pEndpoint</strong> (<code>src/p2p_endpoint.rs</code>): Primary user-facing API for P2P networking</li>
<li><strong>P2pConfig</strong> (<code>src/unified_config.rs</code>): Configuration with builder pattern</li>
<li><strong>NatConfig</strong>: NAT traversal tuning options</li>
<li><strong>PqcConfig</strong>: Post-quantum cryptography tuning (cannot disable PQC)</li>
<li><strong>MtuConfig</strong>: MTU configuration for PQC overhead</li>
</ul>
<h3 id="primary-api-p2pendpoint"><a class="header" href="#primary-api-p2pendpoint">Primary API: P2pEndpoint</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ant_quic::{P2pEndpoint, P2pConfig};

let config = P2pConfig::builder()
    .known_peer("peer.example.com:9000".parse()?)
    .build()?;

let endpoint = P2pEndpoint::new(config).await?;

// All nodes are symmetric - can connect AND accept
let conn = endpoint.connect(target).await?;
let incoming = endpoint.accept().await;
<span class="boring">}</span></code></pre>
<h2 id="layer-3-applications"><a class="header" href="#layer-3-applications">Layer 3: Applications</a></h2>
<p>User-facing applications and tools:</p>
<ul>
<li><strong>ant-quic binary</strong> (<code>src/bin/ant-quic.rs</code>): Main executable</li>
<li><strong>Examples</strong> (<code>examples/</code>): Demo applications</li>
<li><strong>Your applications</strong>: Built on top of the P2pEndpoint API</li>
</ul>
<h2 id="symmetric-p2p-model-2"><a class="header" href="#symmetric-p2p-model-2">Symmetric P2P Model</a></h2>
<p>In ant-quic v0.13.0+, all nodes are symmetric:</p>
<pre><code>┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Node A    │◄───►│   Node B    │◄───►│   Node C    │
│ (NAT'd)     │     │ (Public IP) │     │ (NAT'd)     │
└─────────────┘     └─────────────┘     └─────────────┘
      │                   │                   │
      └─────────── All Identical ─────────────┘
</code></pre>
<p>Every node can:</p>
<ul>
<li><strong>Connect</strong> to other nodes (initiate QUIC connections)</li>
<li><strong>Accept</strong> connections from other nodes</li>
<li><strong>Observe</strong> external addresses of connecting peers</li>
<li><strong>Coordinate</strong> NAT traversal for peers</li>
<li><strong>Relay</strong> traffic when direct connection fails</li>
</ul>
<p>There are no special roles (no “bootstrap”, “coordinator”, “server”, “client”). The terms “known peers” refers to addresses you connect to first for address discovery.</p>
<h2 id="security-architecture"><a class="header" href="#security-architecture">Security Architecture</a></h2>
<h3 id="always-on-pqc"><a class="header" href="#always-on-pqc">Always-On PQC</a></h3>
<p>Every connection uses hybrid cryptography:</p>
<pre><code>┌─────────────────┐     ┌─────────────────┐
│   Classical     │     │  Post-Quantum   │
├─────────────────┤     ├─────────────────┤
│    X25519       │  +  │   ML-KEM-768    │ = Hybrid Key Exchange
│    Ed25519      │  +  │   ML-DSA-65     │ = Hybrid Signatures
└─────────────────┘     └─────────────────┘
</code></pre>
<p>Both algorithm families must be broken to compromise security.</p>
<h3 id="raw-public-keys"><a class="header" href="#raw-public-keys">Raw Public Keys</a></h3>
<p>Identity is based on Ed25519 keys without certificates:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ant_quic::key_utils::{generate_ed25519_keypair, derive_peer_id};

let (private_key, public_key) = generate_ed25519_keypair();
let peer_id = derive_peer_id(&amp;public_key);
<span class="boring">}</span></code></pre>
<h2 id="key-design-principles"><a class="header" href="#key-design-principles">Key Design Principles</a></h2>
<ol>
<li><strong>Symmetric</strong>: All nodes are equal - no special infrastructure required</li>
<li><strong>Secure by Default</strong>: 100% PQC on every connection</li>
<li><strong>Modular</strong>: Each layer can be used independently</li>
<li><strong>Extensible</strong>: Easy to add new features</li>
<li><strong>Performant</strong>: Zero-cost abstractions where possible</li>
<li><strong>Testable</strong>: Comprehensive test coverage at each layer</li>
</ol>
<h2 id="data-flow"><a class="header" href="#data-flow">Data Flow</a></h2>
<h3 id="connection-establishment"><a class="header" href="#connection-establishment">Connection Establishment</a></h3>
<ol>
<li><strong>Discovery</strong>: Connect to known peers, receive OBSERVED_ADDRESS frames</li>
<li><strong>Candidate Exchange</strong>: Share candidate addresses via ADD_ADDRESS frames</li>
<li><strong>Coordination</strong>: Synchronize hole punching via PUNCH_ME_NOW frames</li>
<li><strong>Connection</strong>: Establish direct QUIC connection with PQC handshake</li>
<li><strong>Validation</strong>: Verify peer identity via Raw Public Keys</li>
</ol>
<h3 id="address-discovery-1"><a class="header" href="#address-discovery-1">Address Discovery</a></h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant A as Node A
    participant B as Known Peer B

    A-&gt;&gt;B: QUIC Connection
    B-&gt;&gt;A: OBSERVED_ADDRESS (A's external IP:port)
    A-&gt;&gt;A: Store discovered address
    Note over A: Now knows external address
</code></pre>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="#protocol-extensions-1">Protocol Extensions</a></li>
<li><a href="#nat-traversal">NAT Traversal</a></li>
<li><a href="#security-1">Security</a></li>
<li><a href="#api-reference">API Reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="core-components"><a class="header" href="#core-components">Core Components</a></h1>
<p>This page describes the core components of ant-quic’s architecture.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<pre><code>                                                         
                   P2pEndpoint                           
  (Primary API - symmetric P2P operations)               
                                                         $
  P2pConfig      NatConfig      PqcConfig  MtuConfig  
  (builder)      (NAT tuning)   (PQC tune) (MTU tune) 
               4               4            4            $
                   Core QUIC                             
  Endpoint  Connection  Streams  Frames  Crypto     
                                                         
</code></pre>
<h2 id="p2pendpoint"><a class="header" href="#p2pendpoint">P2pEndpoint</a></h2>
<p>The primary user-facing API for P2P networking.</p>
<h3 id="responsibilities"><a class="header" href="#responsibilities">Responsibilities</a></h3>
<ul>
<li>Connection management (connect and accept)</li>
<li>Address discovery coordination</li>
<li>NAT traversal orchestration</li>
<li>Event emission</li>
<li>Statistics collection</li>
</ul>
<h3 id="key-methods"><a class="header" href="#key-methods">Key Methods</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ant_quic::{P2pEndpoint, P2pConfig};

// Create endpoint
let endpoint = P2pEndpoint::new(config).await?;

// Identity
let peer_id = endpoint.peer_id();

// Address discovery
endpoint.connect_bootstrap().await?;
let external = endpoint.external_address();

// Connections
let conn = endpoint.connect(addr).await?;
let incoming = endpoint.accept().await;

// Events
let events = endpoint.subscribe();

// Statistics
let stats = endpoint.stats();
<span class="boring">}</span></code></pre>
<h3 id="symmetric-design"><a class="header" href="#symmetric-design">Symmetric Design</a></h3>
<p>Every P2pEndpoint can:</p>
<ul>
<li><strong>Initiate</strong> connections to other peers</li>
<li><strong>Accept</strong> connections from other peers</li>
<li><strong>Observe</strong> external addresses of connecting peers</li>
<li><strong>Coordinate</strong> NAT traversal for other peers</li>
</ul>
<p>There are no special roles - all nodes are identical.</p>
<h2 id="p2pconfig"><a class="header" href="#p2pconfig">P2pConfig</a></h2>
<p>Configuration builder for P2pEndpoint.</p>
<h3 id="structure"><a class="header" href="#structure">Structure</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>P2pConfig::builder()
    // Network
    .bind_addr(SocketAddr)
    .known_peer(SocketAddr)

    // Components
    .nat(NatConfig)
    .pqc(PqcConfig)
    .mtu(MtuConfig)

    // Limits
    .max_connections(usize)
    .connection_timeout(Duration)
    .idle_timeout(Duration)

    .build()
<span class="boring">}</span></code></pre>
<h2 id="natconfig"><a class="header" href="#natconfig">NatConfig</a></h2>
<p>NAT traversal configuration.</p>
<h3 id="fields"><a class="header" href="#fields">Fields</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>max_candidates</code></td><td><code>usize</code></td><td>Maximum address candidates</td></tr>
<tr><td><code>coordination_timeout</code></td><td><code>Duration</code></td><td>Hole punch coordination timeout</td></tr>
<tr><td><code>discovery_timeout</code></td><td><code>Duration</code></td><td>Candidate discovery timeout</td></tr>
<tr><td><code>enable_symmetric_nat</code></td><td><code>bool</code></td><td>Enable port prediction</td></tr>
<tr><td><code>hole_punch_retries</code></td><td><code>u32</code></td><td>Number of punch attempts</td></tr>
</tbody>
</table>
</div>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let nat = NatConfig {
    max_candidates: 10,
    coordination_timeout: Duration::from_secs(15),
    discovery_timeout: Duration::from_secs(5),
    enable_symmetric_nat: true,
    hole_punch_retries: 5,
    ..Default::default()
};
<span class="boring">}</span></code></pre>
<h2 id="pqcconfig"><a class="header" href="#pqcconfig">PqcConfig</a></h2>
<p>Post-quantum cryptography configuration. Note: PQC cannot be disabled.</p>
<h3 id="fields-1"><a class="header" href="#fields-1">Fields</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>ml_kem</code></td><td><code>bool</code></td><td>Enable ML-KEM-768</td></tr>
<tr><td><code>ml_dsa</code></td><td><code>bool</code></td><td>Enable ML-DSA-65</td></tr>
<tr><td><code>memory_pool_size</code></td><td><code>usize</code></td><td>Key operation buffers</td></tr>
<tr><td><code>handshake_timeout_multiplier</code></td><td><code>f64</code></td><td>Timeout adjustment</td></tr>
</tbody>
</table>
</div>
<h3 id="usage-1"><a class="header" href="#usage-1">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pqc = PqcConfig::builder()
    .ml_kem(true)
    .ml_dsa(true)
    .memory_pool_size(10)
    .handshake_timeout_multiplier(1.5)
    .build()?;
<span class="boring">}</span></code></pre>
<h2 id="mtuconfig"><a class="header" href="#mtuconfig">MtuConfig</a></h2>
<p>MTU configuration for PQC overhead.</p>
<h3 id="fields-2"><a class="header" href="#fields-2">Fields</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>initial</code></td><td><code>u16</code></td><td>Initial MTU</td></tr>
<tr><td><code>min</code></td><td><code>u16</code></td><td>Minimum MTU</td></tr>
<tr><td><code>max</code></td><td><code>u16</code></td><td>Maximum MTU</td></tr>
</tbody>
</table>
</div>
<h3 id="usage-2"><a class="header" href="#usage-2">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mtu = MtuConfig {
    initial: 1200,
    min: 1200,
    max: 1500,
};
<span class="boring">}</span></code></pre>
<h2 id="connection"><a class="header" href="#connection">Connection</a></h2>
<p>A QUIC connection between two peers.</p>
<h3 id="capabilities"><a class="header" href="#capabilities">Capabilities</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Open streams
let (send, recv) = connection.open_bi().await?;
let send = connection.open_uni().await?;

// Accept streams
let (send, recv) = connection.accept_bi().await?;
let recv = connection.accept_uni().await?;

// Stream operations
send.write_all(data).await?;
send.finish()?;
let data = recv.read_to_end(limit).await?;

// Connection management
connection.close(code, reason).await;
let closed = connection.is_closed();
<span class="boring">}</span></code></pre>
<h2 id="peerid"><a class="header" href="#peerid">PeerId</a></h2>
<p>Unique peer identifier derived from Ed25519 public key.</p>
<h3 id="operations"><a class="header" href="#operations">Operations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ant_quic::PeerId;

// Create from hex
let peer_id = PeerId::from_hex("abcd1234...")?;

// Convert to hex
let hex = peer_id.to_hex();

// Get bytes
let bytes = peer_id.as_bytes();
<span class="boring">}</span></code></pre>
<h2 id="p2pevent"><a class="header" href="#p2pevent">P2pEvent</a></h2>
<p>Events emitted by the endpoint.</p>
<h3 id="variants"><a class="header" href="#variants">Variants</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum P2pEvent {
    // Connection lifecycle
    Connected { peer_id: PeerId, addr: SocketAddr },
    Disconnected { peer_id: PeerId, reason: String },
    ConnectionFailed { peer_id: PeerId, reason: String },

    // Address discovery
    AddressDiscovered { addr: SocketAddr },
    AddressChanged { old: SocketAddr, new: SocketAddr },

    // NAT traversal
    HolePunchStarted { peer_id: PeerId },
    HolePunchSucceeded { peer_id: PeerId, addr: SocketAddr },
    HolePunchFailed { peer_id: PeerId, reason: String },

    // Candidates
    CandidatesDiscovered { peer_id: PeerId, count: usize },
}
<span class="boring">}</span></code></pre>
<h3 id="usage-3"><a class="header" href="#usage-3">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut events = endpoint.subscribe();
while let Ok(event) = events.recv().await {
    match event {
        P2pEvent::Connected { peer_id, addr } =&gt; {
            println!("Connected: {} at {}", peer_id.to_hex(), addr);
        }
        // Handle other events...
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre>
<h2 id="candidateaddress"><a class="header" href="#candidateaddress">CandidateAddress</a></h2>
<p>Address candidate for NAT traversal.</p>
<h3 id="structure-1"><a class="header" href="#structure-1">Structure</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CandidateAddress {
    pub addr: SocketAddr,
    pub source: CandidateSource,
    pub priority: u32,
}

pub enum CandidateSource {
    Local,      // Interface address
    Observed,   // OBSERVED_ADDRESS frame
    Predicted,  // Symmetric NAT prediction
}
<span class="boring">}</span></code></pre>
<h3 id="usage-4"><a class="header" href="#usage-4">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let candidates = endpoint.get_local_candidates();
for c in candidates {
    println!("{} from {:?} (priority {})", c.addr, c.source, c.priority);
}
<span class="boring">}</span></code></pre>
<h2 id="endpointstats"><a class="header" href="#endpointstats">EndpointStats</a></h2>
<p>Endpoint statistics.</p>
<h3 id="fields-3"><a class="header" href="#fields-3">Fields</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct EndpointStats {
    pub active_connections: usize,
    pub discovered_addresses: usize,
    pub successful_hole_punches: usize,
    pub failed_hole_punches: usize,
    pub bytes_sent: u64,
    pub bytes_received: u64,
}
<span class="boring">}</span></code></pre>
<h3 id="usage-5"><a class="header" href="#usage-5">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let stats = endpoint.stats();
println!("Active: {}", stats.active_connections);
println!("Discovered: {}", stats.discovered_addresses);
<span class="boring">}</span></code></pre>
<h2 id="key-utilities"><a class="header" href="#key-utilities">Key Utilities</a></h2>
<p>Functions for key management.</p>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ant_quic::key_utils::{
    generate_ed25519_keypair,
    derive_peer_id,
};

// Generate new keypair
let (private_key, public_key) = generate_ed25519_keypair();

// Derive peer ID
let peer_id = derive_peer_id(&amp;public_key);
<span class="boring">}</span></code></pre>
<h2 id="component-interaction"><a class="header" href="#component-interaction">Component Interaction</a></h2>
<pre><code class="language-mermaid">graph TD
    App[Application] --&gt; P2pEndpoint
    P2pEndpoint --&gt; Connection
    P2pEndpoint --&gt; Events[P2pEvent]
    P2pEndpoint --&gt; Stats[EndpointStats]

    Connection --&gt; Streams
    Streams --&gt; Send[SendStream]
    Streams --&gt; Recv[RecvStream]

    P2pConfig --&gt; P2pEndpoint
    NatConfig --&gt; P2pConfig
    PqcConfig --&gt; P2pConfig
    MtuConfig --&gt; P2pConfig
</code></pre>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See Also</a></h2>
<ul>
<li><a href="#architecture">Architecture</a></li>
<li><a href="#api-reference">API Reference</a></li>
<li><a href="#configuration">Configuration</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="nat-traversal"><a class="header" href="#nat-traversal">NAT Traversal</a></h1>
<p>ant-quic implements QUIC-native NAT traversal without requiring STUN, TURN, or ICE protocols. The implementation follows <a href="../../rfcs/draft-seemann-quic-nat-traversal-02.txt">draft-seemann-quic-nat-traversal-02</a>.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>NAT traversal in ant-quic works through:</p>
<ol>
<li><strong>Address Discovery</strong>: Learn your external address from peers</li>
<li><strong>Candidate Exchange</strong>: Share candidate addresses with target peer</li>
<li><strong>Coordinated Hole Punching</strong>: Simultaneous packet exchange to open NAT mappings</li>
<li><strong>Direct Connection</strong>: Establish QUIC connection through the punched hole</li>
</ol>
<h2 id="why-quic-native"><a class="header" href="#why-quic-native">Why QUIC-Native?</a></h2>
<p>Traditional NAT traversal uses separate protocols (STUN/TURN/ICE). ant-quic integrates NAT traversal directly into QUIC:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Traditional</th><th>QUIC-Native</th></tr>
</thead>
<tbody>
<tr><td>STUN servers for address discovery</td><td>OBSERVED_ADDRESS frames from peers</td></tr>
<tr><td>TURN servers for relay</td><td>Any peer can relay</td></tr>
<tr><td>ICE for coordination</td><td>PUNCH_ME_NOW frames for coordination</td></tr>
<tr><td>Separate UDP sockets</td><td>Same QUIC connection</td></tr>
</tbody>
</table>
</div>
<p>Benefits:</p>
<ul>
<li><strong>No external infrastructure</strong>: Any peer can help with discovery</li>
<li><strong>Faster</strong>: Uses existing QUIC connections</li>
<li><strong>Simpler</strong>: One protocol instead of three</li>
<li><strong>Secure</strong>: All traffic encrypted with PQC</li>
</ul>
<h2 id="symmetric-p2p-model-3"><a class="header" href="#symmetric-p2p-model-3">Symmetric P2P Model</a></h2>
<p>In ant-quic v0.13.0+, <strong>all nodes participate equally</strong> in NAT traversal. Any node with a public IP address can serve as the coordination peer that helps two NAT’d nodes connect.</p>
<h2 id="address-discovery-2"><a class="header" href="#address-discovery-2">Address Discovery</a></h2>
<p>When you connect to a peer, they observe your source address and send it back using the OBSERVED_ADDRESS frame (0x9f81a6 for IPv4, 0x9f81a7 for IPv6). This replaces the need for STUN servers.</p>
<h3 id="observed_address-frame-format"><a class="header" href="#observed_address-frame-format">OBSERVED_ADDRESS Frame Format</a></h3>
<pre><code>Frame Type: 0x9f81a6 (IPv4) or 0x9f81a7 (IPv6)
Payload: IP Address (4 or 16 bytes) + Port (2 bytes)
</code></pre>
<h2 id="hole-punching-protocol"><a class="header" href="#hole-punching-protocol">Hole Punching Protocol</a></h2>
<h3 id="step-1-candidate-exchange"><a class="header" href="#step-1-candidate-exchange">Step 1: Candidate Exchange</a></h3>
<p>Nodes share their candidate addresses via ADD_ADDRESS frames (0x3d7e90-91):</p>
<pre><code>ADD_ADDRESS Frame:
- Address ID (variable)
- IP Version (4 or 6)
- IP Address (4 or 16 bytes)
- Port (2 bytes)
- Priority (variable)
</code></pre>
<h3 id="step-2-coordinated-punching"><a class="header" href="#step-2-coordinated-punching">Step 2: Coordinated Punching</a></h3>
<p>The PUNCH_ME_NOW frame (0x3d7e92-93) coordinates timing:</p>
<pre><code>PUNCH_ME_NOW Frame:
- Peer Address ID
- Path ID
- Timestamp
</code></pre>
<p>Both peers send packets simultaneously to punch through their respective NATs.</p>
<h3 id="step-3-connection-establishment"><a class="header" href="#step-3-connection-establishment">Step 3: Connection Establishment</a></h3>
<p>Once the hole is punched, QUIC connection establishment proceeds normally using the newly discovered direct path.</p>
<h2 id="nat-types-supported"><a class="header" href="#nat-types-supported">NAT Types Supported</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>NAT Type</th><th>Success Rate</th></tr>
</thead>
<tbody>
<tr><td>Full Cone</td><td>100%</td></tr>
<tr><td>Address Restricted</td><td>95%+</td></tr>
<tr><td>Port Restricted</td><td>90%+</td></tr>
<tr><td>Symmetric</td><td>70%+</td></tr>
<tr><td>Carrier-Grade NAT (CGNAT)</td><td>60%+</td></tr>
</tbody>
</table>
</div>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>NAT traversal is enabled by default. Configuration options:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ant_quic::P2pConfig;

let config = P2pConfig::builder()
    .known_peers(vec!["peer1.example.com:9000".parse()?])
    .build()?;
<span class="boring">}</span></code></pre>
<h2 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h2>
<p>Check NAT traversal statistics via the metrics system:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let stats = endpoint.get_nat_traversal_stats();
println!("Direct connections: {}", stats.direct_connections);
println!("NAT traversals: {}", stats.successful_traversals);
println!("Success rate: {:.1}%", stats.success_rate() * 100.0);
<span class="boring">}</span></code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="no-external-address-discovered"><a class="header" href="#no-external-address-discovered">No External Address Discovered</a></h3>
<ul>
<li>Ensure at least one peer with a public IP is reachable</li>
<li>Check firewall rules allow UDP traffic</li>
<li>Verify the peer is correctly observing and reporting addresses</li>
</ul>
<h3 id="hole-punch-failures"><a class="header" href="#hole-punch-failures">Hole Punch Failures</a></h3>
<ul>
<li>Symmetric NATs may require multiple attempts</li>
<li>Try increasing the punch attempt timeout</li>
<li>Consider using a relay as fallback</li>
</ul>
<h3 id="connection-timeouts"><a class="header" href="#connection-timeouts">Connection Timeouts</a></h3>
<ul>
<li>Check both peers have correctly exchanged candidates</li>
<li>Verify coordination timing between peers</li>
<li>Enable debug logging for detailed diagnostics</li>
</ul>
<h2 id="see-also-4"><a class="header" href="#see-also-4">See Also</a></h2>
<ul>
<li><a href="../../rfcs/draft-seemann-quic-nat-traversal-02.txt">QUIC NAT Traversal Draft</a></li>
<li><a href="../../rfcs/draft-ietf-quic-address-discovery-00.txt">Address Discovery Draft</a></li>
<li><a href="pqc.html">Post-Quantum Cryptography</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="protocol-extensions-1"><a class="header" href="#protocol-extensions-1">Protocol Extensions</a></h1>
<p>ant-quic extends the QUIC protocol with custom frames and transport parameters for NAT traversal and address discovery.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>ant-quic implements two IETF drafts:</p>
<ul>
<li><strong>NAT Traversal</strong>: draft-seemann-quic-nat-traversal-02</li>
<li><strong>Address Discovery</strong>: draft-ietf-quic-address-discovery-00</li>
</ul>
<p>These extensions use the QUIC extensibility mechanism:</p>
<ul>
<li>Custom transport parameters for capability negotiation</li>
<li>Custom frame types for protocol messages</li>
</ul>
<h2 id="transport-parameters"><a class="header" href="#transport-parameters">Transport Parameters</a></h2>
<p>Transport parameters are exchanged during the QUIC handshake to negotiate capabilities.</p>
<h3 id="nat-traversal-parameters"><a class="header" href="#nat-traversal-parameters">NAT Traversal Parameters</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter ID</th><th>Name</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0x3d7e9f0bca12fea6</td><td>NAT Traversal Capability</td><td>Indicates NAT traversal support</td></tr>
<tr><td>0x3d7e9f0bca12fea8</td><td>RFC-Compliant Frames</td><td>Indicates RFC-compliant frame format</td></tr>
</tbody>
</table>
</div>
<h3 id="address-discovery-parameters"><a class="header" href="#address-discovery-parameters">Address Discovery Parameters</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter ID</th><th>Name</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0x9f81a176</td><td>Address Discovery Config</td><td>Configuration for address observation</td></tr>
</tbody>
</table>
</div>
<h3 id="negotiation"><a class="header" href="#negotiation">Negotiation</a></h3>
<p>Both endpoints must advertise support for NAT traversal in their transport parameters. If either endpoint doesn’t support it, NAT traversal is disabled for that connection.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Transport parameters are automatically negotiated
// Check if NAT traversal is available:
let nat_available = connection.nat_traversal_supported();
<span class="boring">}</span></code></pre>
<h2 id="extension-frames"><a class="header" href="#extension-frames">Extension Frames</a></h2>
<h3 id="add_address-frame"><a class="header" href="#add_address-frame">ADD_ADDRESS Frame</a></h3>
<p>Advertises a candidate address to the peer.</p>
<p><strong>Frame Types:</strong></p>
<ul>
<li><code>0x3d7e90</code>: IPv4 address</li>
<li><code>0x3d7e91</code>: IPv6 address</li>
</ul>
<p><strong>Format:</strong></p>
<pre><code>ADD_ADDRESS Frame {
    Address ID (i),
    Sequence Number (i),
    IP Address (32 or 128 bits),
    Port (16 bits)
}
</code></pre>
<p><strong>Fields:</strong></p>
<ul>
<li><code>Address ID</code>: Unique identifier for this address</li>
<li><code>Sequence Number</code>: Monotonically increasing for conflict resolution</li>
<li><code>IP Address</code>: IPv4 (4 bytes) or IPv6 (16 bytes) address</li>
<li><code>Port</code>: UDP port number</li>
</ul>
<h3 id="punch_me_now-frame"><a class="header" href="#punch_me_now-frame">PUNCH_ME_NOW Frame</a></h3>
<p>Coordinates simultaneous hole punching between two peers.</p>
<p><strong>Frame Types:</strong></p>
<ul>
<li><code>0x3d7e92</code>: IPv4 target address</li>
<li><code>0x3d7e93</code>: IPv6 target address</li>
</ul>
<p><strong>Format:</strong></p>
<pre><code>PUNCH_ME_NOW Frame {
    Coordination ID (i),
    Target IP Address (32 or 128 bits),
    Target Port (16 bits)
}
</code></pre>
<p><strong>Fields:</strong></p>
<ul>
<li><code>Coordination ID</code>: Unique identifier for this punch attempt</li>
<li><code>Target IP Address</code>: Address to send packets to</li>
<li><code>Target Port</code>: Port to send packets to</li>
</ul>
<h3 id="remove_address-frame"><a class="header" href="#remove_address-frame">REMOVE_ADDRESS Frame</a></h3>
<p>Removes a previously advertised address.</p>
<p><strong>Frame Type:</strong> <code>0x3d7e94</code></p>
<p><strong>Format:</strong></p>
<pre><code>REMOVE_ADDRESS Frame {
    Address ID (i),
    Sequence Number (i)
}
</code></pre>
<h3 id="observed_address-frame"><a class="header" href="#observed_address-frame">OBSERVED_ADDRESS Frame</a></h3>
<p>Reports the external address observed by the peer.</p>
<p><strong>Frame Types:</strong></p>
<ul>
<li><code>0x9f81a6</code>: IPv4 address</li>
<li><code>0x9f81a7</code>: IPv6 address</li>
</ul>
<p><strong>Format:</strong></p>
<pre><code>OBSERVED_ADDRESS Frame {
    IP Address (32 or 128 bits),
    Port (16 bits)
}
</code></pre>
<p>This is how address discovery works - when you connect to a peer, they see your source address and send it back to you.</p>
<h2 id="frame-processing"><a class="header" href="#frame-processing">Frame Processing</a></h2>
<h3 id="sending-frames"><a class="header" href="#sending-frames">Sending Frames</a></h3>
<p>Frames are sent through the standard QUIC connection:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Internal: frames are sent automatically
// ADD_ADDRESS when discovering candidates
// PUNCH_ME_NOW when coordinating hole punch
// OBSERVED_ADDRESS on incoming connections
<span class="boring">}</span></code></pre>
<h3 id="receiving-frames"><a class="header" href="#receiving-frames">Receiving Frames</a></h3>
<p>The endpoint processes extension frames automatically:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Subscribe to events for frame outcomes
let mut events = endpoint.subscribe();
while let Ok(event) = events.recv().await {
    match event {
        P2pEvent::AddressDiscovered { addr } =&gt; {
            // Received OBSERVED_ADDRESS
        }
        P2pEvent::CandidatesDiscovered { peer_id, count } =&gt; {
            // Received ADD_ADDRESS frames
        }
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre>
<h2 id="variable-length-integer-encoding"><a class="header" href="#variable-length-integer-encoding">Variable-Length Integer Encoding</a></h2>
<p>Frame fields marked with <code>(i)</code> use QUIC’s variable-length integer encoding:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>2MSB</th><th>Length</th><th>Usable Bits</th><th>Range</th></tr>
</thead>
<tbody>
<tr><td>00</td><td>1 byte</td><td>6 bits</td><td>0-63</td></tr>
<tr><td>01</td><td>2 bytes</td><td>14 bits</td><td>0-16383</td></tr>
<tr><td>10</td><td>4 bytes</td><td>30 bits</td><td>0-1073741823</td></tr>
<tr><td>11</td><td>8 bytes</td><td>62 bits</td><td>0-4611686018427387903</td></tr>
</tbody>
</table>
</div>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="frame-validation"><a class="header" href="#frame-validation">Frame Validation</a></h3>
<p>All extension frames are validated:</p>
<ul>
<li>Address IDs must be unique</li>
<li>Sequence numbers must be monotonically increasing</li>
<li>IP addresses are checked for validity</li>
<li>Rate limiting prevents flooding</li>
</ul>
<h3 id="authentication"><a class="header" href="#authentication">Authentication</a></h3>
<p>Extension frames are only processed from authenticated peers. Since ant-quic uses Raw Public Keys (RFC 7250), peer identity is verified during the QUIC handshake.</p>
<h3 id="encryption"><a class="header" href="#encryption">Encryption</a></h3>
<p>All frames are encrypted using QUIC’s encryption. In v0.13.0+, this includes hybrid PQC (ML-KEM-768).</p>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<h3 id="frame-ids"><a class="header" href="#frame-ids">Frame IDs</a></h3>
<p>The frame IDs follow QUIC’s extensibility rules:</p>
<ul>
<li>Use the experimental range to avoid conflicts</li>
<li>Include versioning for future compatibility</li>
</ul>
<h3 id="compatibility"><a class="header" href="#compatibility">Compatibility</a></h3>
<p>ant-quic’s extension frames are backward compatible:</p>
<ul>
<li>Peers that don’t understand extensions ignore them</li>
<li>Transport parameters negotiate capability</li>
</ul>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li><a href="https://www.rfc-editor.org/rfc/rfc9000">RFC 9000</a> - QUIC Transport Protocol</li>
<li><a href="../../rfcs/draft-seemann-quic-nat-traversal-02.txt">draft-seemann-quic-nat-traversal-02</a></li>
<li><a href="../../rfcs/draft-ietf-quic-address-discovery-00.txt">draft-ietf-quic-address-discovery-00</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<p>This page provides a comprehensive reference for ant-quic’s public API in v0.13.0+.</p>
<h2 id="primary-api-p2pendpoint-1"><a class="header" href="#primary-api-p2pendpoint-1">Primary API: P2pEndpoint</a></h2>
<p>The main entry point for all P2P operations.</p>
<h3 id="creating-an-endpoint"><a class="header" href="#creating-an-endpoint">Creating an Endpoint</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ant_quic::{P2pEndpoint, P2pConfig};

let config = P2pConfig::builder()
    .known_peer("peer.example.com:9000".parse()?)
    .build()?;

let endpoint = P2pEndpoint::new(config).await?;
<span class="boring">}</span></code></pre>
<h3 id="p2pendpoint-methods"><a class="header" href="#p2pendpoint-methods">P2pEndpoint Methods</a></h3>
<h4 id="identity"><a class="header" href="#identity">Identity</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get the local peer ID (derived from Ed25519 public key)
let peer_id: PeerId = endpoint.peer_id();

// Get the peer ID as hex string
let hex: String = peer_id.to_hex();
<span class="boring">}</span></code></pre>
<h4 id="address-discovery-3"><a class="header" href="#address-discovery-3">Address Discovery</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Connect to known peers and discover external address
endpoint.connect_bootstrap().await?;

// Get the discovered external address
let external: Option&lt;SocketAddr&gt; = endpoint.external_address();

// Get all discovered addresses
let addresses: Vec&lt;SocketAddr&gt; = endpoint.discovered_addresses();
<span class="boring">}</span></code></pre>
<h4 id="connections"><a class="header" href="#connections">Connections</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Connect to a peer by address
let connection = endpoint.connect("192.168.1.100:9000".parse()?).await?;

// Connect to a peer by ID through a known peer
let connection = endpoint.connect_via_peer(peer_id, known_peer_addr).await?;

// Accept incoming connections
while let Some(conn) = endpoint.accept().await {
    // Handle connection
}

// Close all connections
endpoint.close_all_connections().await;
<span class="boring">}</span></code></pre>
<h4 id="events-1"><a class="header" href="#events-1">Events</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Subscribe to P2P events
let mut events = endpoint.subscribe();

while let Ok(event) = events.recv().await {
    match event {
        P2pEvent::Connected { peer_id, addr } =&gt; { ... }
        P2pEvent::Disconnected { peer_id, reason } =&gt; { ... }
        P2pEvent::AddressDiscovered { addr } =&gt; { ... }
        // ... more events
    }
}
<span class="boring">}</span></code></pre>
<h4 id="statistics"><a class="header" href="#statistics">Statistics</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get endpoint statistics
let stats: EndpointStats = endpoint.stats();
println!("Active connections: {}", stats.active_connections);
println!("Discovered addresses: {}", stats.discovered_addresses);
<span class="boring">}</span></code></pre>
<h2 id="configuration-types"><a class="header" href="#configuration-types">Configuration Types</a></h2>
<h3 id="p2pconfig-1"><a class="header" href="#p2pconfig-1">P2pConfig</a></h3>
<p>Builder pattern for endpoint configuration.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = P2pConfig::builder()
    .bind_addr("0.0.0.0:9000".parse()?)
    .known_peer("peer.example.com:9000".parse()?)
    .nat(NatConfig { ... })
    .pqc(PqcConfig::builder().build()?)
    .mtu(MtuConfig { ... })
    .max_connections(100)
    .connection_timeout(Duration::from_secs(30))
    .idle_timeout(Duration::from_secs(60))
    .build()?;
<span class="boring">}</span></code></pre>
<h3 id="natconfig-1"><a class="header" href="#natconfig-1">NatConfig</a></h3>
<p>NAT traversal configuration.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NatConfig {
    pub max_candidates: usize,
    pub coordination_timeout: Duration,
    pub discovery_timeout: Duration,
    pub enable_symmetric_nat: bool,
    pub hole_punch_retries: u32,
}
<span class="boring">}</span></code></pre>
<h3 id="pqcconfig-1"><a class="header" href="#pqcconfig-1">PqcConfig</a></h3>
<p>Post-quantum cryptography configuration (cannot disable PQC).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pqc = PqcConfig::builder()
    .ml_kem(true)      // ML-KEM-768
    .ml_dsa(true)      // ML-DSA-65
    .memory_pool_size(10)
    .handshake_timeout_multiplier(1.5)
    .build()?;
<span class="boring">}</span></code></pre>
<h3 id="mtuconfig-1"><a class="header" href="#mtuconfig-1">MtuConfig</a></h3>
<p>MTU configuration for PQC overhead.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MtuConfig {
    pub initial: u16,
    pub min: u16,
    pub max: u16,
}
<span class="boring">}</span></code></pre>
<h2 id="event-types"><a class="header" href="#event-types">Event Types</a></h2>
<h3 id="p2pevent-1"><a class="header" href="#p2pevent-1">P2pEvent</a></h3>
<p>Events emitted by the endpoint.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum P2pEvent {
    // Connection events
    Connected { peer_id: PeerId, addr: SocketAddr },
    Disconnected { peer_id: PeerId, reason: String },
    ConnectionFailed { peer_id: PeerId, reason: String },

    // Address discovery events
    AddressDiscovered { addr: SocketAddr },
    AddressChanged { old: SocketAddr, new: SocketAddr },

    // NAT traversal events
    HolePunchStarted { peer_id: PeerId },
    HolePunchSucceeded { peer_id: PeerId, addr: SocketAddr },
    HolePunchFailed { peer_id: PeerId, reason: String },

    // Candidate events
    CandidatesDiscovered { peer_id: PeerId, count: usize },
}
<span class="boring">}</span></code></pre>
<h2 id="identity-types"><a class="header" href="#identity-types">Identity Types</a></h2>
<h3 id="peerid-1"><a class="header" href="#peerid-1">PeerId</a></h3>
<p>Peer identity derived from Ed25519 public key.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ant_quic::PeerId;

// Create from hex string
let peer_id = PeerId::from_hex("abcd1234...")?;

// Convert to hex string
let hex = peer_id.to_hex();

// Get the underlying bytes
let bytes: &amp;[u8] = peer_id.as_bytes();
<span class="boring">}</span></code></pre>
<h3 id="key-utilities-1"><a class="header" href="#key-utilities-1">Key Utilities</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ant_quic::key_utils::{
    generate_ed25519_keypair,
    derive_peer_id,
};

// Generate a new keypair
let (private_key, public_key) = generate_ed25519_keypair();

// Derive peer ID from public key
let peer_id = derive_peer_id(&amp;public_key);
<span class="boring">}</span></code></pre>
<h2 id="connection-type"><a class="header" href="#connection-type">Connection Type</a></h2>
<p>QUIC connection with streams.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Open a bidirectional stream
let (mut send, mut recv) = connection.open_bi().await?;

// Send data
send.write_all(b"Hello").await?;
send.finish()?;

// Receive data
let data = recv.read_to_end(4096).await?;

// Open a unidirectional stream
let mut send = connection.open_uni().await?;

// Accept streams
let (send, recv) = connection.accept_bi().await?;
let recv = connection.accept_uni().await?;

// Close the connection
connection.close(0u32.into(), b"goodbye").await;

// Check if connection is closed
let closed: bool = connection.is_closed();
<span class="boring">}</span></code></pre>
<h2 id="statistics-types"><a class="header" href="#statistics-types">Statistics Types</a></h2>
<h3 id="endpointstats-1"><a class="header" href="#endpointstats-1">EndpointStats</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct EndpointStats {
    pub active_connections: usize,
    pub discovered_addresses: usize,
    pub successful_hole_punches: usize,
    pub failed_hole_punches: usize,
    pub bytes_sent: u64,
    pub bytes_received: u64,
}
<span class="boring">}</span></code></pre>
<h2 id="error-types"><a class="header" href="#error-types">Error Types</a></h2>
<h3 id="endpointerror"><a class="header" href="#endpointerror">EndpointError</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum EndpointError {
    BindFailed(std::io::Error),
    ConnectionFailed(String),
    Timeout,
    InvalidConfiguration(String),
    // ...
}
<span class="boring">}</span></code></pre>
<h3 id="nattraversalerror"><a class="header" href="#nattraversalerror">NatTraversalError</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum NatTraversalError {
    NoViableCandidates,
    CoordinationTimeout,
    HolePunchFailed(String),
    // ...
}
<span class="boring">}</span></code></pre>
<h2 id="candidate-types"><a class="header" href="#candidate-types">Candidate Types</a></h2>
<h3 id="candidateaddress-1"><a class="header" href="#candidateaddress-1">CandidateAddress</a></h3>
<p>Address candidate for NAT traversal.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CandidateAddress {
    pub addr: SocketAddr,
    pub source: CandidateSource,
    pub priority: u32,
}

pub enum CandidateSource {
    Local,       // Local interface address
    Observed,    // Discovered via OBSERVED_ADDRESS
    Predicted,   // Symmetric NAT port prediction
}
<span class="boring">}</span></code></pre>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get local candidates
let candidates = endpoint.get_local_candidates();

for candidate in candidates {
    println!("{} from {:?} (priority: {})",
        candidate.addr,
        candidate.source,
        candidate.priority
    );
}
<span class="boring">}</span></code></pre>
<h2 id="removed-api-v0130"><a class="header" href="#removed-api-v0130">Removed API (v0.13.0)</a></h2>
<p>The following types were removed in v0.13.0:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Removed</th><th>Replacement</th></tr>
</thead>
<tbody>
<tr><td><code>QuicNodeConfig</code></td><td><code>P2pConfig</code></td></tr>
<tr><td><code>QuicP2PNode</code></td><td><code>P2pEndpoint</code></td></tr>
<tr><td><code>EndpointRole</code></td><td>(removed - all nodes symmetric)</td></tr>
<tr><td><code>NatTraversalRole</code></td><td>(removed - all nodes symmetric)</td></tr>
<tr><td><code>PqcMode</code></td><td>(removed - PQC always on)</td></tr>
<tr><td><code>HybridPreference</code></td><td>(removed - no mode selection)</td></tr>
</tbody>
</table>
</div>
<h2 id="full-example-1"><a class="header" href="#full-example-1">Full Example</a></h2>
<pre class="playground"><code class="language-rust">use ant_quic::{P2pEndpoint, P2pConfig, P2pEvent, NatConfig};
use std::time::Duration;

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    // Configure
    let config = P2pConfig::builder()
        .known_peer("quic.saorsalabs.com:9000".parse()?)
        .nat(NatConfig {
            max_candidates: 10,
            coordination_timeout: Duration::from_secs(15),
            ..Default::default()
        })
        .build()?;

    // Create endpoint
    let endpoint = P2pEndpoint::new(config).await?;
    println!("Peer ID: {}", endpoint.peer_id().to_hex());

    // Discover address
    endpoint.connect_bootstrap().await?;
    println!("External: {:?}", endpoint.external_address());

    // Subscribe to events
    let mut events = endpoint.subscribe();
    tokio::spawn(async move {
        while let Ok(event) = events.recv().await {
            println!("Event: {:?}", event);
        }
    });

    // Connect to peer
    let connection = endpoint.connect("192.168.1.100:9000".parse()?).await?;

    // Use connection
    let (mut send, mut recv) = connection.open_bi().await?;
    send.write_all(b"Hello!").await?;
    send.finish()?;

    let response = recv.read_to_end(1024).await?;
    println!("Response: {:?}", response);

    Ok(())
}</code></pre>
<h2 id="see-also-5"><a class="header" href="#see-also-5">See Also</a></h2>
<ul>
<li><a href="https://docs.rs/ant-quic">docs.rs/ant-quic</a> - Autogenerated API documentation</li>
<li><a href="#configuration">Configuration</a> - Configuration options</li>
<li><a href="#examples">Examples</a> - More examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>ant-quic has a comprehensive test suite with 580+ tests covering all functionality.</p>
<h2 id="test-organization"><a class="header" href="#test-organization">Test Organization</a></h2>
<pre><code>src/
   */mod.rs          # Unit tests embedded in modules
tests/
   *.rs              # Integration tests
examples/
   *.rs              # Functional examples (also tests)
</code></pre>
<h3 id="test-categories"><a class="header" href="#test-categories">Test Categories</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Location</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>Unit Tests</td><td><code>src/*/mod.rs</code></td><td>Component isolation</td></tr>
<tr><td>Integration Tests</td><td><code>tests/*.rs</code></td><td>Cross-component behavior</td></tr>
<tr><td>Property Tests</td><td>Throughout</td><td>Invariant verification</td></tr>
<tr><td>Example Tests</td><td><code>examples/*.rs</code></td><td>API usage validation</td></tr>
</tbody>
</table>
</div>
<h2 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h2>
<h3 id="full-test-suite"><a class="header" href="#full-test-suite">Full Test Suite</a></h3>
<pre><code class="language-bash"># Run all tests
cargo test

# Run with output
cargo test -- --nocapture

# Run in parallel (default)
cargo test -- --test-threads=8
</code></pre>
<h3 id="specific-test-categories"><a class="header" href="#specific-test-categories">Specific Test Categories</a></h3>
<pre><code class="language-bash"># NAT traversal tests
cargo test nat_traversal

# Candidate discovery tests
cargo test candidate_discovery

# Connection tests
cargo test connection

# PQC tests
cargo test pqc
cargo test ml_kem
cargo test ml_dsa

# Property tests
cargo test proptest
</code></pre>
<h3 id="stress-tests"><a class="header" href="#stress-tests">Stress Tests</a></h3>
<p>Stress tests are normally ignored to keep CI fast:</p>
<pre><code class="language-bash"># Run stress tests
cargo test -- --ignored stress

# All tests including stress
cargo test -- --include-ignored
</code></pre>
<h2 id="test-features"><a class="header" href="#test-features">Test Features</a></h2>
<h3 id="test-utilities"><a class="header" href="#test-utilities">Test Utilities</a></h3>
<p>Enable test utilities for helper functions:</p>
<pre><code class="language-toml">[dev-dependencies]
ant-quic = { version = "0.13", features = ["test-utils"] }
</code></pre>
<h3 id="network-simulation"><a class="header" href="#network-simulation">Network Simulation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ant_quic::test_utils::{pair, server, client};

#[tokio::test]
async fn test_connection() {
    let (client, server) = pair(Default::default());

    // Test connection establishment
    let conn = client.connect(server.addr()).await.unwrap();
    assert!(!conn.is_closed());
}
<span class="boring">}</span></code></pre>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h2>
<h3 id="unit-test-pattern"><a class="header" href="#unit-test-pattern">Unit Test Pattern</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_peer_id_from_hex() {
        let hex = "abcd1234...";
        let peer_id = PeerId::from_hex(hex).unwrap();
        assert_eq!(peer_id.to_hex(), hex);
    }

    #[tokio::test]
    async fn test_endpoint_creation() {
        let config = P2pConfig::builder().build().unwrap();
        let endpoint = P2pEndpoint::new(config).await.unwrap();
        assert!(endpoint.peer_id().as_bytes().len() &gt; 0);
    }
}
<span class="boring">}</span></code></pre>
<h3 id="integration-test-pattern"><a class="header" href="#integration-test-pattern">Integration Test Pattern</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/nat_traversal.rs
use ant_quic::{P2pEndpoint, P2pConfig, P2pEvent};

#[tokio::test]
async fn test_hole_punch_between_nodes() {
    // Create two endpoints
    let config1 = P2pConfig::builder().build().unwrap();
    let config2 = P2pConfig::builder().build().unwrap();

    let ep1 = P2pEndpoint::new(config1).await.unwrap();
    let ep2 = P2pEndpoint::new(config2).await.unwrap();

    // Connect and verify
    let conn = ep1.connect(ep2.local_addr()).await.unwrap();
    assert!(!conn.is_closed());
}
<span class="boring">}</span></code></pre>
<h2 id="logging-in-tests"><a class="header" href="#logging-in-tests">Logging in Tests</a></h2>
<pre><code class="language-bash"># Enable debug logging
RUST_LOG=ant_quic=debug cargo test -- --nocapture

# Specific module logging
RUST_LOG=ant_quic::nat_traversal=trace cargo test nat_traversal -- --nocapture

# PQC logging
RUST_LOG=ant_quic::crypto::pqc=debug cargo test pqc -- --nocapture
</code></pre>
<h2 id="coverage"><a class="header" href="#coverage">Coverage</a></h2>
<p>Generate test coverage reports:</p>
<pre><code class="language-bash"># Install tarpaulin
cargo install cargo-tarpaulin

# Run with coverage
cargo tarpaulin --out Html

# Open report
open tarpaulin-report.html
</code></pre>
<h2 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h2>
<p>Tests run automatically on every PR:</p>
<pre><code class="language-yaml"># .github/workflows/test.yml
- name: Run tests
  run: |
    cargo fmt --all -- --check
    cargo clippy --all-targets -- -D warnings
    cargo test --locked
</code></pre>
<h2 id="see-also-6"><a class="header" href="#see-also-6">See Also</a></h2>
<ul>
<li><a href="#unit-tests">Unit Tests</a> - Unit testing details</li>
<li><a href="#integration-tests">Integration Tests</a> - Integration testing</li>
<li><a href="#property-based-tests">Property Tests</a> - Property-based testing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h1>
<p>Unit tests verify individual components in isolation.</p>
<h2 id="organization"><a class="header" href="#organization">Organization</a></h2>
<p>Unit tests are embedded in source files:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/peer_id.rs
pub struct PeerId([u8; 32]);

impl PeerId {
    pub fn from_hex(hex: &amp;str) -&gt; Result&lt;Self, Error&gt; {
        // ...
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_from_hex_valid() {
        let hex = "a".repeat(64);
        assert!(PeerId::from_hex(&amp;hex).is_ok());
    }

    #[test]
    fn test_from_hex_invalid_length() {
        let hex = "abc";
        assert!(PeerId::from_hex(hex).is_err());
    }
}
<span class="boring">}</span></code></pre>
<h2 id="running-unit-tests"><a class="header" href="#running-unit-tests">Running Unit Tests</a></h2>
<pre><code class="language-bash"># All unit tests
cargo test --lib

# Specific module
cargo test peer_id

# Specific test
cargo test test_from_hex_valid

# With output
cargo test --lib -- --nocapture
</code></pre>
<h2 id="key-test-modules"><a class="header" href="#key-test-modules">Key Test Modules</a></h2>
<h3 id="peerid-tests"><a class="header" href="#peerid-tests">PeerId Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod peer_id_tests {
    use super::*;

    #[test]
    fn roundtrip_hex() {
        let (_, public_key) = generate_ed25519_keypair();
        let peer_id = derive_peer_id(&amp;public_key);

        let hex = peer_id.to_hex();
        let recovered = PeerId::from_hex(&amp;hex).unwrap();

        assert_eq!(peer_id, recovered);
    }
}
<span class="boring">}</span></code></pre>
<h3 id="configuration-tests"><a class="header" href="#configuration-tests">Configuration Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod config_tests {
    use super::*;

    #[test]
    fn builder_defaults() {
        let config = P2pConfig::builder().build().unwrap();

        assert!(config.known_peers.is_empty());
        assert_eq!(config.max_connections, 100);
    }

    #[test]
    fn builder_with_known_peer() {
        let addr = "192.168.1.1:9000".parse().unwrap();
        let config = P2pConfig::builder()
            .known_peer(addr)
            .build()
            .unwrap();

        assert_eq!(config.known_peers.len(), 1);
    }
}
<span class="boring">}</span></code></pre>
<h3 id="frame-tests"><a class="header" href="#frame-tests">Frame Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod frame_tests {
    use super::*;

    #[test]
    fn encode_decode_add_address() {
        let frame = AddAddressFrame {
            sequence: 1,
            addr: "192.168.1.1:9000".parse().unwrap(),
        };

        let mut buf = Vec::new();
        frame.encode(&amp;mut buf);

        let decoded = AddAddressFrame::decode(&amp;buf).unwrap();
        assert_eq!(frame.sequence, decoded.sequence);
    }
}
<span class="boring">}</span></code></pre>
<h3 id="candidate-tests"><a class="header" href="#candidate-tests">Candidate Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod candidate_tests {
    use super::*;

    #[test]
    fn priority_calculation() {
        let local = CandidateAddress {
            addr: "192.168.1.1:9000".parse().unwrap(),
            source: CandidateSource::Local,
            priority: 0,
        };

        let observed = CandidateAddress {
            addr: "203.0.113.1:9000".parse().unwrap(),
            source: CandidateSource::Observed,
            priority: 0,
        };

        // Observed addresses should have higher priority
        assert!(observed.calculate_priority() &gt; local.calculate_priority());
    }
}
<span class="boring">}</span></code></pre>
<h2 id="async-unit-tests"><a class="header" href="#async-unit-tests">Async Unit Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod async_tests {
    use super::*;

    #[tokio::test]
    async fn endpoint_creation() {
        let config = P2pConfig::builder().build().unwrap();
        let endpoint = P2pEndpoint::new(config).await;

        assert!(endpoint.is_ok());
    }

    #[tokio::test]
    async fn event_subscription() {
        let config = P2pConfig::builder().build().unwrap();
        let endpoint = P2pEndpoint::new(config).await.unwrap();

        let events = endpoint.subscribe();
        // Verify subscription works
        drop(events);
    }
}
<span class="boring">}</span></code></pre>
<h2 id="test-utilities-1"><a class="header" href="#test-utilities-1">Test Utilities</a></h2>
<h3 id="test-helpers"><a class="header" href="#test-helpers">Test Helpers</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test_helpers {
    pub fn test_config() -&gt; P2pConfig {
        P2pConfig::builder()
            .bind_addr("127.0.0.1:0".parse().unwrap())
            .build()
            .unwrap()
    }

    pub fn random_peer_id() -&gt; PeerId {
        let (_, pk) = generate_ed25519_keypair();
        derive_peer_id(&amp;pk)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="mock-implementations"><a class="header" href="#mock-implementations">Mock Implementations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
struct MockConnection {
    closed: bool,
}

#[cfg(test)]
impl MockConnection {
    fn new() -&gt; Self {
        Self { closed: false }
    }

    fn close(&amp;mut self) {
        self.closed = true;
    }
}
<span class="boring">}</span></code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Test one thing per test</strong></li>
<li><strong>Use descriptive test names</strong></li>
<li><strong>Test edge cases and error paths</strong></li>
<li><strong>Keep tests fast (&lt; 100ms each)</strong></li>
<li><strong>Avoid network I/O in unit tests</strong></li>
</ol>
<h2 id="see-also-7"><a class="header" href="#see-also-7">See Also</a></h2>
<ul>
<li><a href="#testing">Testing Overview</a></li>
<li><a href="#integration-tests">Integration Tests</a></li>
<li><a href="#property-based-tests">Property Tests</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h1>
<p>Integration tests verify cross-component behavior and realistic usage scenarios.</p>
<h2 id="organization-1"><a class="header" href="#organization-1">Organization</a></h2>
<p>Integration tests are in the <code>tests/</code> directory:</p>
<pre><code>tests/
   nat_traversal_comprehensive.rs  # NAT traversal scenarios
   connection_establishment.rs      # Connection lifecycle
   address_discovery.rs             # Address discovery
   pqc_integration.rs               # Post-quantum crypto
   *.rs                             # Other tests
</code></pre>
<h2 id="running-integration-tests"><a class="header" href="#running-integration-tests">Running Integration Tests</a></h2>
<pre><code class="language-bash"># All integration tests
cargo test --test '*'

# Specific test file
cargo test --test nat_traversal_comprehensive

# Specific test
cargo test --test connection_establishment test_basic_connection

# With logging
RUST_LOG=ant_quic=debug cargo test --test nat_traversal_comprehensive -- --nocapture
</code></pre>
<h2 id="key-integration-tests"><a class="header" href="#key-integration-tests">Key Integration Tests</a></h2>
<h3 id="connection-establishment-1"><a class="header" href="#connection-establishment-1">Connection Establishment</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/connection_establishment.rs
use ant_quic::{P2pEndpoint, P2pConfig};

#[tokio::test]
async fn test_basic_connection() {
    // Create two endpoints
    let config1 = P2pConfig::builder()
        .bind_addr("127.0.0.1:0".parse().unwrap())
        .build()
        .unwrap();
    let config2 = P2pConfig::builder()
        .bind_addr("127.0.0.1:0".parse().unwrap())
        .build()
        .unwrap();

    let ep1 = P2pEndpoint::new(config1).await.unwrap();
    let ep2 = P2pEndpoint::new(config2).await.unwrap();

    // Connect from ep1 to ep2
    let conn = ep1.connect(ep2.local_addr()).await.unwrap();

    assert!(!conn.is_closed());
}
<span class="boring">}</span></code></pre>
<h3 id="bidirectional-streams"><a class="header" href="#bidirectional-streams">Bidirectional Streams</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_bidirectional_stream() {
    let (ep1, ep2) = create_pair().await;

    // Connect
    let conn = ep1.connect(ep2.local_addr()).await.unwrap();

    // Open stream and send
    let (mut send, mut recv) = conn.open_bi().await.unwrap();
    send.write_all(b"Hello").await.unwrap();
    send.finish().unwrap();

    // Accept and receive on server side
    let server_conn = ep2.accept().await.unwrap();
    let (mut server_send, mut server_recv) = server_conn.accept_bi().await.unwrap();

    let data = server_recv.read_to_end(1024).await.unwrap();
    assert_eq!(&amp;data, b"Hello");
}
<span class="boring">}</span></code></pre>
<h3 id="address-discovery-4"><a class="header" href="#address-discovery-4">Address Discovery</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_address_discovery_via_peer() {
    // Create a "known peer" with public binding
    let known_peer = P2pEndpoint::new(
        P2pConfig::builder()
            .bind_addr("127.0.0.1:0".parse().unwrap())
            .build()
            .unwrap()
    ).await.unwrap();

    // Create client that will discover its address
    let client = P2pEndpoint::new(
        P2pConfig::builder()
            .known_peer(known_peer.local_addr())
            .build()
            .unwrap()
    ).await.unwrap();

    // Connect to known peer
    client.connect_bootstrap().await.unwrap();

    // Should have discovered an address
    assert!(client.external_address().is_some());
}
<span class="boring">}</span></code></pre>
<h3 id="nat-traversal-simulation"><a class="header" href="#nat-traversal-simulation">NAT Traversal Simulation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_hole_punch_simulation() {
    // Create coordinator
    let coordinator = P2pEndpoint::new(
        P2pConfig::builder()
            .bind_addr("127.0.0.1:0".parse().unwrap())
            .build()
            .unwrap()
    ).await.unwrap();

    // Create two endpoints behind simulated NAT
    let ep1 = P2pEndpoint::new(
        P2pConfig::builder()
            .known_peer(coordinator.local_addr())
            .build()
            .unwrap()
    ).await.unwrap();

    let ep2 = P2pEndpoint::new(
        P2pConfig::builder()
            .known_peer(coordinator.local_addr())
            .build()
            .unwrap()
    ).await.unwrap();

    // Both discover their addresses
    ep1.connect_bootstrap().await.unwrap();
    ep2.connect_bootstrap().await.unwrap();

    // Exchange candidates and punch
    // (in real scenario, this happens via coordinator)
    let conn = ep1.connect(ep2.local_addr()).await.unwrap();
    assert!(!conn.is_closed());
}
<span class="boring">}</span></code></pre>
<h3 id="event-monitoring"><a class="header" href="#event-monitoring">Event Monitoring</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_connection_events() {
    let ep1 = create_endpoint().await;
    let ep2 = create_endpoint().await;

    let mut events1 = ep1.subscribe();

    // Connect
    let _conn = ep1.connect(ep2.local_addr()).await.unwrap();

    // Should receive Connected event
    let event = tokio::time::timeout(
        Duration::from_secs(5),
        events1.recv()
    ).await.unwrap().unwrap();

    matches!(event, P2pEvent::Connected { .. });
}
<span class="boring">}</span></code></pre>
<h2 id="nat-simulation"><a class="header" href="#nat-simulation">NAT Simulation</a></h2>
<p>The test suite includes NAT simulation for realistic scenarios:</p>
<h3 id="nat-types"><a class="header" href="#nat-types">NAT Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SimulatedNatType {
    FullCone,         // Most permissive
    RestrictedCone,   // Source IP restricted
    PortRestricted,   // Source IP + port restricted
    Symmetric,        // Different mapping per destination
}
<span class="boring">}</span></code></pre>
<h3 id="multi-nat-test"><a class="header" href="#multi-nat-test">Multi-NAT Test</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_symmetric_nat_traversal() {
    let coordinator = create_public_endpoint().await;

    let nat1 = SimulatedNat::new(SimulatedNatType::Symmetric);
    let nat2 = SimulatedNat::new(SimulatedNatType::PortRestricted);

    let ep1 = create_endpoint_behind_nat(&amp;nat1).await;
    let ep2 = create_endpoint_behind_nat(&amp;nat2).await;

    // Both connect to coordinator for address discovery
    ep1.connect_via_nat(coordinator.local_addr()).await.unwrap();
    ep2.connect_via_nat(coordinator.local_addr()).await.unwrap();

    // Attempt hole punch (may fail for symmetric NAT)
    let result = ep1.connect_with_hole_punch(ep2.peer_id()).await;

    // Symmetric NAT to Port Restricted should succeed with prediction
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre>
<h2 id="docker-based-tests"><a class="header" href="#docker-based-tests">Docker-Based Tests</a></h2>
<p>For realistic NAT testing, use Docker:</p>
<pre><code class="language-bash"># Run Docker NAT simulation
docker-compose -f docker/nat-test/docker-compose.yml up

# Run tests against Docker network
DOCKER_NAT_TEST=1 cargo test --test nat_traversal_comprehensive
</code></pre>
<h2 id="test-fixtures"><a class="header" href="#test-fixtures">Test Fixtures</a></h2>
<h3 id="creating-endpoint-pairs"><a class="header" href="#creating-endpoint-pairs">Creating Endpoint Pairs</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn create_pair() -&gt; (P2pEndpoint, P2pEndpoint) {
    let config = || P2pConfig::builder()
        .bind_addr("127.0.0.1:0".parse().unwrap())
        .build()
        .unwrap();

    let ep1 = P2pEndpoint::new(config()).await.unwrap();
    let ep2 = P2pEndpoint::new(config()).await.unwrap();

    (ep1, ep2)
}
<span class="boring">}</span></code></pre>
<h3 id="test-timeouts"><a class="header" href="#test-timeouts">Test Timeouts</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_with_timeout() {
    let result = tokio::time::timeout(
        Duration::from_secs(30),
        async {
            // Test logic here
        }
    ).await;

    assert!(result.is_ok(), "Test timed out");
}
<span class="boring">}</span></code></pre>
<h2 id="see-also-8"><a class="header" href="#see-also-8">See Also</a></h2>
<ul>
<li><a href="#testing">Testing Overview</a></li>
<li><a href="#unit-tests">Unit Tests</a></li>
<li><a href="#property-based-tests">Property Tests</a></li>
<li><a href="../deployment/docker.html">Docker Testing</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="property-based-tests"><a class="header" href="#property-based-tests">Property-Based Tests</a></h1>
<p>Property-based testing verifies that code maintains invariants across randomly generated inputs.</p>
<h2 id="using-proptest"><a class="header" href="#using-proptest">Using Proptest</a></h2>
<p>ant-quic uses <a href="https://proptest-rs.github.io/proptest/">proptest</a> for property-based testing.</p>
<h3 id="basic-example"><a class="header" href="#basic-example">Basic Example</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proptest::prelude::*;

proptest! {
    #[test]
    fn peer_id_roundtrip(bytes in any::&lt;[u8; 32]&gt;()) {
        let peer_id = PeerId::from_bytes(bytes);
        let hex = peer_id.to_hex();
        let recovered = PeerId::from_hex(&amp;hex).unwrap();
        prop_assert_eq!(peer_id, recovered);
    }
}
<span class="boring">}</span></code></pre>
<h2 id="running-property-tests"><a class="header" href="#running-property-tests">Running Property Tests</a></h2>
<pre><code class="language-bash"># All property tests
cargo test proptest

# With more cases
PROPTEST_CASES=10000 cargo test proptest

# Specific property test
cargo test peer_id_roundtrip

# With verbose output
cargo test proptest -- --nocapture
</code></pre>
<h2 id="key-properties"><a class="header" href="#key-properties">Key Properties</a></h2>
<h3 id="frame-encodingdecoding"><a class="header" href="#frame-encodingdecoding">Frame Encoding/Decoding</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>proptest! {
    #[test]
    fn add_address_frame_roundtrip(
        sequence in 0u64..u64::MAX,
        ip in any::&lt;[u8; 4]&gt;(),
        port in 1024u16..65535,
    ) {
        let addr = SocketAddr::new(
            IpAddr::V4(Ipv4Addr::from(ip)),
            port
        );

        let frame = AddAddressFrame { sequence, addr };

        let mut buf = Vec::new();
        frame.encode(&amp;mut buf);

        let decoded = AddAddressFrame::decode(&amp;buf).unwrap();

        prop_assert_eq!(frame.sequence, decoded.sequence);
        prop_assert_eq!(frame.addr, decoded.addr);
    }
}
<span class="boring">}</span></code></pre>
<h3 id="candidate-priority"><a class="header" href="#candidate-priority">Candidate Priority</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>proptest! {
    #[test]
    fn candidate_priority_ordering(
        candidates in prop::collection::vec(arb_candidate(), 1..100)
    ) {
        let mut sorted = candidates.clone();
        sorted.sort_by_key(|c| std::cmp::Reverse(c.priority));

        // Verify sorting is stable
        for i in 1..sorted.len() {
            prop_assert!(sorted[i-1].priority &gt;= sorted[i].priority);
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="configuration-validation"><a class="header" href="#configuration-validation">Configuration Validation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>proptest! {
    #[test]
    fn config_builder_validates(
        max_conns in 1usize..1000,
        timeout_ms in 1000u64..60000,
    ) {
        let result = P2pConfig::builder()
            .max_connections(max_conns)
            .connection_timeout(Duration::from_millis(timeout_ms))
            .build();

        prop_assert!(result.is_ok());

        let config = result.unwrap();
        prop_assert_eq!(config.max_connections, max_conns);
    }
}
<span class="boring">}</span></code></pre>
<h3 id="variable-length-integer-encoding-1"><a class="header" href="#variable-length-integer-encoding-1">Variable-Length Integer Encoding</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>proptest! {
    #[test]
    fn varint_roundtrip(value in 0u64..=0x3FFF_FFFF_FFFF_FFFF) {
        let mut buf = Vec::new();
        encode_varint(value, &amp;mut buf);

        let decoded = decode_varint(&amp;buf).unwrap();

        prop_assert_eq!(value, decoded);
    }
}
<span class="boring">}</span></code></pre>
<h2 id="custom-strategies"><a class="header" href="#custom-strategies">Custom Strategies</a></h2>
<h3 id="arbitrary-addresses"><a class="header" href="#arbitrary-addresses">Arbitrary Addresses</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn arb_socket_addr() -&gt; impl Strategy&lt;Value = SocketAddr&gt; {
    (any::&lt;[u8; 4]&gt;(), 1024u16..65535).prop_map(|(ip, port)| {
        SocketAddr::new(
            IpAddr::V4(Ipv4Addr::from(ip)),
            port
        )
    })
}
<span class="boring">}</span></code></pre>
<h3 id="arbitrary-candidates"><a class="header" href="#arbitrary-candidates">Arbitrary Candidates</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn arb_candidate() -&gt; impl Strategy&lt;Value = CandidateAddress&gt; {
    (
        arb_socket_addr(),
        prop_oneof![
            Just(CandidateSource::Local),
            Just(CandidateSource::Observed),
            Just(CandidateSource::Predicted),
        ],
        0u32..1000,
    ).prop_map(|(addr, source, priority)| {
        CandidateAddress { addr, source, priority }
    })
}
<span class="boring">}</span></code></pre>
<h3 id="arbitrary-events"><a class="header" href="#arbitrary-events">Arbitrary Events</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn arb_event() -&gt; impl Strategy&lt;Value = P2pEvent&gt; {
    prop_oneof![
        (arb_peer_id(), arb_socket_addr()).prop_map(|(peer_id, addr)| {
            P2pEvent::Connected { peer_id, addr }
        }),
        arb_socket_addr().prop_map(|addr| {
            P2pEvent::AddressDiscovered { addr }
        }),
    ]
}
<span class="boring">}</span></code></pre>
<h2 id="regression-testing"><a class="header" href="#regression-testing">Regression Testing</a></h2>
<p>When proptest finds a failure, it saves it:</p>
<pre><code>tests/proptest-regressions/
   frame_tests.txt
   candidate_tests.txt
   config_tests.txt
</code></pre>
<p>These are automatically replayed on subsequent runs.</p>
<h3 id="manual-regression"><a class="header" href="#manual-regression">Manual Regression</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>proptest! {
    #[test]
    fn test_with_regression(x in 0..100) {
        // If this fails for x=42, add:
        // #[test_case(42)]
        prop_assert!(x != 42);
    }
}

// Explicit regression test
#[test]
fn regression_42() {
    // Test the specific failing case
}
<span class="boring">}</span></code></pre>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<h3 id="increase-test-cases"><a class="header" href="#increase-test-cases">Increase Test Cases</a></h3>
<pre><code class="language-bash"># Default: 256 cases
cargo test proptest

# More cases for CI
PROPTEST_CASES=10000 cargo test proptest

# Maximum coverage
PROPTEST_CASES=100000 cargo test proptest -- --test-threads=1
</code></pre>
<h3 id="proptest-config-file"><a class="header" href="#proptest-config-file">Proptest Config File</a></h3>
<p>Create <code>proptest-config.toml</code>:</p>
<pre><code class="language-toml">[default]
cases = 1000
max_shrink_iters = 10000

[fork]
timeout = 60000
</code></pre>
<h2 id="shrinking"><a class="header" href="#shrinking">Shrinking</a></h2>
<p>Proptest automatically shrinks failing inputs to minimal examples:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>proptest! {
    #[test]
    fn finds_minimal_failure(s in ".*") {
        prop_assert!(s.len() &lt; 10);
    }
}
// Will shrink "abcdefghijk" to "aaaaaaaaaa" (minimal 10-char string)
<span class="boring">}</span></code></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li><strong>Test invariants, not specific values</strong></li>
<li><strong>Use appropriate value ranges</strong></li>
<li><strong>Combine with unit tests for edge cases</strong></li>
<li><strong>Commit regression files</strong></li>
<li><strong>Increase cases in CI</strong></li>
</ol>
<h2 id="see-also-9"><a class="header" href="#see-also-9">See Also</a></h2>
<ul>
<li><a href="#testing">Testing Overview</a></li>
<li><a href="#unit-tests">Unit Tests</a></li>
<li><a href="#integration-tests">Integration Tests</a></li>
<li><a href="https://proptest-rs.github.io/proptest/">proptest documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-tuning"><a class="header" href="#performance-tuning">Performance Tuning</a></h1>
<p>This guide covers performance optimization for ant-quic.</p>
<h2 id="pqc-performance-impact"><a class="header" href="#pqc-performance-impact">PQC Performance Impact</a></h2>
<p>Post-quantum cryptography adds overhead to handshakes:</p>
<h3 id="handshake-sizes"><a class="header" href="#handshake-sizes">Handshake Sizes</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Phase</th><th>Classical</th><th>Hybrid PQC</th><th>Increase</th></tr>
</thead>
<tbody>
<tr><td>ClientHello</td><td>~300 bytes</td><td>~1,600 bytes</td><td>+1,300</td></tr>
<tr><td>ServerHello</td><td>~1,200 bytes</td><td>~5,500 bytes</td><td>+4,300</td></tr>
<tr><td>Total Handshake</td><td>~2KB</td><td>~8KB</td><td>~4x</td></tr>
</tbody>
</table>
</div>
<h3 id="handshake-latency"><a class="header" href="#handshake-latency">Handshake Latency</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Classical</th><th>Hybrid PQC</th><th>Impact</th></tr>
</thead>
<tbody>
<tr><td>Key Generation</td><td>0.1ms</td><td>0.8ms</td><td>+700%</td></tr>
<tr><td>Key Exchange</td><td>0.2ms</td><td>1.2ms</td><td>+500%</td></tr>
<tr><td>Signature</td><td>0.1ms</td><td>2.5ms</td><td>+2400%</td></tr>
<tr><td>Total Handshake</td><td>~0.5ms</td><td>~5ms</td><td>~10x</td></tr>
</tbody>
</table>
</div>
<p><strong>Note</strong>: These overheads only affect connection establishment. Data transfer speed is identical.</p>
<h3 id="mitigations"><a class="header" href="#mitigations">Mitigations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pqc = PqcConfig::builder()
    // Use memory pool to reduce allocations
    .memory_pool_size(20)
    // Adjust timeout for PQC overhead
    .handshake_timeout_multiplier(2.0)
    .build()?;
<span class="boring">}</span></code></pre>
<h2 id="connection-management"><a class="header" href="#connection-management">Connection Management</a></h2>
<h3 id="maximum-connections"><a class="header" href="#maximum-connections">Maximum Connections</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = P2pConfig::builder()
    // Limit concurrent connections
    .max_connections(100)
    // Set idle timeout
    .idle_timeout(Duration::from_secs(60))
    .build()?;
<span class="boring">}</span></code></pre>
<h3 id="connection-reuse"><a class="header" href="#connection-reuse">Connection Reuse</a></h3>
<p>Reuse connections instead of creating new ones:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Keep connections in a map
let mut connections: HashMap&lt;PeerId, Connection&gt; = HashMap::new();

// Reuse existing connection
if let Some(conn) = connections.get(&amp;peer_id) {
    if !conn.is_closed() {
        return conn.clone();
    }
}

// Create new if needed
let conn = endpoint.connect(addr).await?;
connections.insert(peer_id, conn.clone());
<span class="boring">}</span></code></pre>
<h2 id="nat-traversal-tuning"><a class="header" href="#nat-traversal-tuning">NAT Traversal Tuning</a></h2>
<h3 id="candidate-discovery"><a class="header" href="#candidate-discovery">Candidate Discovery</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let nat = NatConfig {
    // Limit candidates for faster pairing
    max_candidates: 10,

    // Shorter discovery for responsive UX
    discovery_timeout: Duration::from_secs(3),

    // More retries for difficult NATs
    hole_punch_retries: 5,

    ..Default::default()
};
<span class="boring">}</span></code></pre>
<h3 id="symmetric-nat"><a class="header" href="#symmetric-nat">Symmetric NAT</a></h3>
<p>For symmetric NATs, port prediction adds overhead:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let nat = NatConfig {
    // Enable for symmetric NAT support (slight overhead)
    enable_symmetric_nat: true,

    // More candidates for port prediction
    max_candidates: 15,

    ..Default::default()
};
<span class="boring">}</span></code></pre>
<h2 id="mtu-configuration-1"><a class="header" href="#mtu-configuration-1">MTU Configuration</a></h2>
<h3 id="pqc-aware-mtu"><a class="header" href="#pqc-aware-mtu">PQC-Aware MTU</a></h3>
<p>PQC increases handshake packet sizes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mtu = MtuConfig {
    // Conservative initial MTU
    initial: 1200,

    // Minimum for QUIC
    min: 1200,

    // Maximum after path validation
    max: 1500,
};
<span class="boring">}</span></code></pre>
<h3 id="networks-with-low-mtu"><a class="header" href="#networks-with-low-mtu">Networks with Low MTU</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For VPNs, tunnels, or restrictive networks
let mtu = MtuConfig {
    initial: 1200,
    min: 1200,
    max: 1280, // Conservative max
};
<span class="boring">}</span></code></pre>
<h2 id="memory-optimization"><a class="header" href="#memory-optimization">Memory Optimization</a></h2>
<h3 id="buffer-pools"><a class="header" href="#buffer-pools">Buffer Pools</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pqc = PqcConfig::builder()
    // Reuse crypto buffers
    .memory_pool_size(10)
    .build()?;
<span class="boring">}</span></code></pre>
<h3 id="connection-limits"><a class="header" href="#connection-limits">Connection Limits</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = P2pConfig::builder()
    // Limit memory per connection
    .max_connections(50)
    // Close idle connections
    .idle_timeout(Duration::from_secs(30))
    .build()?;
<span class="boring">}</span></code></pre>
<h2 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h2>
<h3 id="running-benchmarks"><a class="header" href="#running-benchmarks">Running Benchmarks</a></h3>
<pre><code class="language-bash"># Run all benchmarks
cargo bench

# Specific benchmark
cargo bench handshake

# With profiling
cargo bench -- --profile-time=10
</code></pre>
<h3 id="custom-benchmarks"><a class="header" href="#custom-benchmarks">Custom Benchmarks</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use criterion::{criterion_group, criterion_main, Criterion};

fn benchmark_connection(c: &amp;mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();

    c.bench_function("connect", |b| {
        b.iter(|| {
            rt.block_on(async {
                let config = P2pConfig::builder().build().unwrap();
                let endpoint = P2pEndpoint::new(config).await.unwrap();
                // Connect to peer...
            })
        })
    });
}

criterion_group!(benches, benchmark_connection);
criterion_main!(benches);
<span class="boring">}</span></code></pre>
<h2 id="profiling"><a class="header" href="#profiling">Profiling</a></h2>
<h3 id="cpu-profiling"><a class="header" href="#cpu-profiling">CPU Profiling</a></h3>
<pre><code class="language-bash"># With perf
cargo build --release
perf record -g ./target/release/ant-quic
perf report

# With flamegraph
cargo install flamegraph
cargo flamegraph --bin ant-quic
</code></pre>
<h3 id="memory-profiling"><a class="header" href="#memory-profiling">Memory Profiling</a></h3>
<pre><code class="language-bash"># With valgrind
cargo build --release
valgrind --tool=massif ./target/release/ant-quic

# With heaptrack
heaptrack ./target/release/ant-quic
heaptrack_gui heaptrack.ant-quic.*.gz
</code></pre>
<h2 id="monitoring-1"><a class="header" href="#monitoring-1">Monitoring</a></h2>
<h3 id="statistics-1"><a class="header" href="#statistics-1">Statistics</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    tokio::time::sleep(Duration::from_secs(10)).await;

    let stats = endpoint.stats();

    println!("Active connections: {}", stats.active_connections);
    println!("Bytes sent: {}", stats.bytes_sent);
    println!("Bytes received: {}", stats.bytes_received);
    println!("Successful punches: {}", stats.successful_hole_punches);
    println!("Failed punches: {}", stats.failed_hole_punches);
}
<span class="boring">}</span></code></pre>
<h3 id="logging-for-performance"><a class="header" href="#logging-for-performance">Logging for Performance</a></h3>
<pre><code class="language-bash"># Minimal logging for production
RUST_LOG=warn cargo run --release

# Connection timing
RUST_LOG=ant_quic::connection=info cargo run

# Full debug (impacts performance)
RUST_LOG=ant_quic=debug cargo run
</code></pre>
<h2 id="platform-specific-optimization"><a class="header" href="#platform-specific-optimization">Platform-Specific Optimization</a></h2>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<pre><code class="language-bash"># Increase UDP buffer sizes
sudo sysctl -w net.core.rmem_max=26214400
sudo sysctl -w net.core.wmem_max=26214400
</code></pre>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<pre><code class="language-bash"># Increase socket buffer sizes
sudo sysctl -w kern.ipc.maxsockbuf=8388608
</code></pre>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>Configure via registry:</p>
<ul>
<li><code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\AFD\Parameters</code></li>
<li><code>DefaultReceiveWindow</code></li>
<li><code>DefaultSendWindow</code></li>
</ul>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li><strong>Reuse connections</strong> - Don’t create new connections for each request</li>
<li><strong>Tune timeouts</strong> - Adjust for your network conditions</li>
<li><strong>Monitor statistics</strong> - Track connection success rates</li>
<li><strong>Profile before optimizing</strong> - Measure don’t guess</li>
<li><strong>Use release builds</strong> - Debug builds are 10-100x slower</li>
</ol>
<h2 id="see-also-10"><a class="header" href="#see-also-10">See Also</a></h2>
<ul>
<li><a href="#configuration">Configuration</a> - Full configuration reference</li>
<li><a href="#troubleshooting-1">Troubleshooting</a> - Common issues</li>
<li><a href="#platform-support">Platform Support</a> - Platform details</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="security-1"><a class="header" href="#security-1">Security</a></h1>
<p>ant-quic v0.13.0+ provides comprehensive security through always-on Post-Quantum Cryptography and Raw Public Key authentication.</p>
<h2 id="security-model"><a class="header" href="#security-model">Security Model</a></h2>
<h3 id="always-on-pqc-1"><a class="header" href="#always-on-pqc-1">Always-On PQC</a></h3>
<p><strong>Every connection uses hybrid cryptography</strong> - there is no way to disable PQC:</p>
<pre><code>                                       
   Classical            Post-Quantum   
                 $                      $
    X25519         +     ML-KEM-768     = Hybrid Key Exchange
    Ed25519        +     ML-DSA-65      = Hybrid Signatures
                                       
</code></pre>
<p><strong>Security Property</strong>: An attacker must break BOTH algorithm families to compromise security.</p>
<h3 id="why-always-on"><a class="header" href="#why-always-on">Why Always-On?</a></h3>
<ol>
<li><strong>“Harvest Now, Decrypt Later”</strong>: Adversaries can record encrypted traffic today and decrypt when quantum computers arrive</li>
<li><strong>No Configuration Errors</strong>: Users cannot accidentally disable PQC</li>
<li><strong>Consistent Security</strong>: Every connection has identical protection</li>
<li><strong>Performance</strong>: Modern hardware handles ~8% overhead easily</li>
</ol>
<h2 id="cryptographic-algorithms"><a class="header" href="#cryptographic-algorithms">Cryptographic Algorithms</a></h2>
<h3 id="key-exchange"><a class="header" href="#key-exchange">Key Exchange</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Algorithm</th><th>Standard</th><th>Security Level</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>X25519</td><td>RFC 7748</td><td>128-bit classical</td><td>Elliptic curve DH</td></tr>
<tr><td>ML-KEM-768</td><td>FIPS 203</td><td>192-bit classical, 175-bit quantum</td><td>Post-quantum KEM</td></tr>
</tbody>
</table>
</div>
<p>Both are used together - the shared secret combines both results.</p>
<h3 id="digital-signatures"><a class="header" href="#digital-signatures">Digital Signatures</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Algorithm</th><th>Standard</th><th>Security Level</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>Ed25519</td><td>RFC 8032</td><td>128-bit classical</td><td>Classical signatures</td></tr>
<tr><td>ML-DSA-65</td><td>FIPS 204</td><td>192-bit classical, 175-bit quantum</td><td>Post-quantum signatures</td></tr>
</tbody>
</table>
</div>
<h3 id="key-sizes"><a class="header" href="#key-sizes">Key Sizes</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>ML-KEM-768</th><th>X25519</th></tr>
</thead>
<tbody>
<tr><td>Public Key</td><td>1,184 bytes</td><td>32 bytes</td></tr>
<tr><td>Ciphertext</td><td>1,088 bytes</td><td>32 bytes</td></tr>
</tbody>
</table>
</div>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>ML-DSA-65</th><th>Ed25519</th></tr>
</thead>
<tbody>
<tr><td>Public Key</td><td>1,952 bytes</td><td>32 bytes</td></tr>
<tr><td>Signature</td><td>3,293 bytes</td><td>64 bytes</td></tr>
</tbody>
</table>
</div>
<h2 id="raw-public-keys-1"><a class="header" href="#raw-public-keys-1">Raw Public Keys</a></h2>
<p>ant-quic uses Raw Public Keys (RFC 7250) instead of X.509 certificates:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ant_quic::key_utils::{generate_ed25519_keypair, derive_peer_id};

// Generate Ed25519 keypair
let (private_key, public_key) = generate_ed25519_keypair();

// Derive peer ID from public key
let peer_id = derive_peer_id(&amp;public_key);
<span class="boring">}</span></code></pre>
<h3 id="benefits"><a class="header" href="#benefits">Benefits</a></h3>
<ol>
<li><strong>No PKI Required</strong>: No certificate authorities needed</li>
<li><strong>Self-Sovereign Identity</strong>: Nodes control their own keys</li>
<li><strong>Simple Trust Model</strong>: Trust is established by knowing peer IDs</li>
<li><strong>Small Footprint</strong>: No certificate chain overhead</li>
</ol>
<h3 id="peer-verification"><a class="header" href="#peer-verification">Peer Verification</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Verify a peer by their known ID
let expected_peer_id = PeerId::from_hex("abcd1234...")?;

endpoint.subscribe().recv().await {
    P2pEvent::Connected { peer_id, .. } =&gt; {
        if peer_id == expected_peer_id {
            // Trusted peer
        } else {
            // Unknown peer
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="transport-security"><a class="header" href="#transport-security">Transport Security</a></h2>
<p>All QUIC traffic is encrypted using AEAD:</p>
<ul>
<li><strong>Handshake</strong>: TLS 1.3 with hybrid PQC key exchange</li>
<li><strong>Application Data</strong>: AES-128-GCM or ChaCha20-Poly1305</li>
<li><strong>Header Protection</strong>: Additional header encryption</li>
</ul>
<h3 id="forward-secrecy"><a class="header" href="#forward-secrecy">Forward Secrecy</a></h3>
<p>Ephemeral keys are used for each connection:</p>
<ul>
<li>New X25519 keypair per connection</li>
<li>New ML-KEM-768 keypair per connection</li>
<li>Compromise of one connection doesn’t affect others</li>
</ul>
<h2 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h2>
<h3 id="protected-against"><a class="header" href="#protected-against">Protected Against</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>Protection</th></tr>
</thead>
<tbody>
<tr><td>Eavesdropping</td><td>TLS 1.3 encryption</td></tr>
<tr><td>Man-in-the-Middle</td><td>Peer authentication</td></tr>
<tr><td>Replay Attacks</td><td>QUIC nonces</td></tr>
<tr><td>Quantum Computers</td><td>ML-KEM-768 + ML-DSA-65</td></tr>
<tr><td>Key Compromise</td><td>Forward secrecy</td></tr>
</tbody>
</table>
</div>
<h3 id="attack-scenarios"><a class="header" href="#attack-scenarios">Attack Scenarios</a></h3>
<h4 id="if-classical-algorithm-compromised"><a class="header" href="#if-classical-algorithm-compromised">If Classical Algorithm Compromised</a></h4>
<ul>
<li><strong>Impact</strong>: Limited - PQC still protects</li>
<li><strong>Action</strong>: Continue operating, await updates</li>
</ul>
<h4 id="if-pqc-algorithm-compromised"><a class="header" href="#if-pqc-algorithm-compromised">If PQC Algorithm Compromised</a></h4>
<ul>
<li><strong>Impact</strong>: Limited - classical still protects</li>
<li><strong>Action</strong>: Continue operating, await updates</li>
</ul>
<h4 id="if-both-compromised-unlikely"><a class="header" href="#if-both-compromised-unlikely">If Both Compromised (Unlikely)</a></h4>
<ul>
<li><strong>Impact</strong>: Critical</li>
<li><strong>Action</strong>: Emergency key rotation</li>
</ul>
<h2 id="side-channel-protection"><a class="header" href="#side-channel-protection">Side-Channel Protection</a></h2>
<p>ant-quic implements countermeasures:</p>
<ol>
<li><strong>Constant-Time Operations</strong>: No data-dependent branches</li>
<li><strong>Memory Protection</strong>: Key zeroization after use</li>
<li><strong>Stack Clearing</strong>: Sensitive variables cleared</li>
</ol>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<h3 id="key-management"><a class="header" href="#key-management">Key Management</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Generate unique keypair per node
let (private_key, public_key) = generate_ed25519_keypair();

// 2. Store private key securely
// Never log or expose private keys

// 3. Rotate keys periodically for long-running services
impl KeyRotation for YourApp {
    fn should_rotate(&amp;self, key_age: Duration) -&gt; bool {
        key_age &gt; Duration::from_days(90)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="network-security"><a class="header" href="#network-security">Network Security</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Use multiple known peers
let config = P2pConfig::builder()
    .known_peer("peer1.example.com:9000".parse()?)
    .known_peer("peer2.example.com:9000".parse()?)
    .known_peer("peer3.example.com:9000".parse()?)
    .build()?;

// 2. Verify peer identities in your application
// 3. Implement rate limiting for connections
<span class="boring">}</span></code></pre>
<h3 id="monitoring-2"><a class="header" href="#monitoring-2">Monitoring</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Monitor for security events
let mut events = endpoint.subscribe();
while let Ok(event) = events.recv().await {
    match event {
        P2pEvent::ConnectionFailed { peer_id, reason } =&gt; {
            // Log failed connections
            warn!("Connection failed: {} - {}", peer_id.to_hex(), reason);
        }
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre>
<h2 id="compliance"><a class="header" href="#compliance">Compliance</a></h2>
<h3 id="nist-standards"><a class="header" href="#nist-standards">NIST Standards</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Standard</th><th>Algorithm</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>FIPS 203</td><td>ML-KEM-768</td><td>Final 2024</td></tr>
<tr><td>FIPS 204</td><td>ML-DSA-65</td><td>Final 2024</td></tr>
<tr><td>SP 800-56C Rev. 2</td><td>Key Derivation</td><td>Compliant</td></tr>
<tr><td>SP 800-90A Rev. 1</td><td>RNG</td><td>Compliant</td></tr>
</tbody>
</table>
</div>
<h3 id="security-audit-checklist"><a class="header" href="#security-audit-checklist">Security Audit Checklist</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""> PQC enabled (automatic - cannot be disabled)</li>
<li><input disabled="" type="checkbox" checked=""> Hybrid mode active (automatic)</li>
<li><input disabled="" type="checkbox"> Latest stable release installed</li>
<li><input disabled="" type="checkbox"> Security advisories monitored</li>
<li><input disabled="" type="checkbox"> Key rotation schedule implemented</li>
<li><input disabled="" type="checkbox"> Peer verification in application</li>
<li><input disabled="" type="checkbox"> Logging and monitoring active</li>
</ul>
<h2 id="reporting-security-issues"><a class="header" href="#reporting-security-issues">Reporting Security Issues</a></h2>
<p>For security vulnerabilities:</p>
<ul>
<li><strong>GitHub Security Advisories</strong>: <a href="https://github.com/dirvine/ant-quic/security">ant-quic/security</a></li>
<li><strong>Email</strong>: security@autonomi.org</li>
</ul>
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<ul>
<li><a href="../../rfcs/fips-203-ml-kem.pdf">FIPS 203 - ML-KEM</a></li>
<li><a href="../../rfcs/fips-204-ml-dsa.pdf">FIPS 204 - ML-DSA</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc7250">RFC 7250 - Raw Public Keys</a></li>
<li><a href="../../docs/guides/pqc-security.html">PQC Security Guide</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h1>
<p>ant-quic supports multiple platforms with varying levels of support.</p>
<h2 id="support-tiers"><a class="header" href="#support-tiers">Support Tiers</a></h2>
<h3 id="tier-1-full-support"><a class="header" href="#tier-1-full-support">Tier 1: Full Support</a></h3>
<p>Fully tested, CI coverage, production ready.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Architecture</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Linux</td><td>x86_64</td><td>Primary development platform</td></tr>
<tr><td>Linux</td><td>aarch64</td><td>ARM64 servers</td></tr>
<tr><td>macOS</td><td>x86_64</td><td>Intel Macs</td></tr>
<tr><td>macOS</td><td>aarch64</td><td>Apple Silicon</td></tr>
<tr><td>Windows</td><td>x86_64</td><td>Windows 10+</td></tr>
</tbody>
</table>
</div>
<h3 id="tier-2-best-effort"><a class="header" href="#tier-2-best-effort">Tier 2: Best Effort</a></h3>
<p>Builds and passes tests, but not in regular CI.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Architecture</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Linux</td><td>armv7</td><td>Raspberry Pi, embedded</td></tr>
<tr><td>Android</td><td>aarch64</td><td>Mobile devices</td></tr>
<tr><td>Android</td><td>x86_64</td><td>Emulators</td></tr>
<tr><td>FreeBSD</td><td>x86_64</td><td>BSD servers</td></tr>
</tbody>
</table>
</div>
<h3 id="not-supported"><a class="header" href="#not-supported">Not Supported</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>WASM</td><td>No raw UDP sockets</td></tr>
<tr><td>iOS</td><td>Restricted networking APIs</td></tr>
<tr><td>Browser</td><td>Sandbox restrictions</td></tr>
</tbody>
</table>
</div>
<h2 id="platform-specific-notes"><a class="header" href="#platform-specific-notes">Platform-Specific Notes</a></h2>
<h3 id="linux-1"><a class="header" href="#linux-1">Linux</a></h3>
<p><strong>Requirements</strong>:</p>
<ul>
<li>glibc 2.17+ (or musl)</li>
<li>Kernel 3.10+</li>
<li>UDP networking</li>
</ul>
<p><strong>Optimizations</strong>:</p>
<pre><code class="language-bash"># Increase UDP buffer sizes
sudo sysctl -w net.core.rmem_max=26214400
sudo sysctl -w net.core.wmem_max=26214400
</code></pre>
<p><strong>NAT Traversal</strong>:</p>
<ul>
<li>Full support on all NAT types</li>
<li>Best connectivity rates</li>
</ul>
<h3 id="macos-1"><a class="header" href="#macos-1">macOS</a></h3>
<p><strong>Requirements</strong>:</p>
<ul>
<li>macOS 10.13+ (High Sierra)</li>
<li>Xcode Command Line Tools (for building)</li>
</ul>
<p><strong>Optimizations</strong>:</p>
<pre><code class="language-bash">sudo sysctl -w kern.ipc.maxsockbuf=8388608
</code></pre>
<p><strong>Known Limitations</strong>:</p>
<ul>
<li>Some corporate networks may block UDP</li>
</ul>
<h3 id="windows-1"><a class="header" href="#windows-1">Windows</a></h3>
<p><strong>Requirements</strong>:</p>
<ul>
<li>Windows 10 version 1607+</li>
<li>Visual Studio Build Tools (for building)</li>
<li>Windows Firewall exceptions for UDP</li>
</ul>
<p><strong>Firewall Configuration</strong>:</p>
<pre><code class="language-powershell"># Allow UDP for your application
New-NetFirewallRule -DisplayName "ant-quic" -Direction Inbound -Protocol UDP -LocalPort 9000 -Action Allow
</code></pre>
<p><strong>Registry Optimization</strong>:</p>
<pre><code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\AFD\Parameters
  DefaultReceiveWindow = 8388608
  DefaultSendWindow = 8388608
</code></pre>
<h3 id="android"><a class="header" href="#android">Android</a></h3>
<p><strong>Requirements</strong>:</p>
<ul>
<li>API level 21+ (Android 5.0)</li>
<li>Network permission in manifest</li>
</ul>
<p><strong>Manifest</strong>:</p>
<pre><code class="language-xml">&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;
</code></pre>
<p><strong>Limitations</strong>:</p>
<ul>
<li>Battery optimization may affect background connections</li>
<li>VPN interoperability varies</li>
</ul>
<h3 id="freebsd"><a class="header" href="#freebsd">FreeBSD</a></h3>
<p><strong>Requirements</strong>:</p>
<ul>
<li>FreeBSD 12+</li>
<li>clang or gcc</li>
</ul>
<p><strong>Building</strong>:</p>
<pre><code class="language-bash">pkg install rust cmake
cargo build --release
</code></pre>
<h2 id="building-for-different-platforms"><a class="header" href="#building-for-different-platforms">Building for Different Platforms</a></h2>
<h3 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-Compilation</a></h3>
<pre><code class="language-bash"># Add target
rustup target add aarch64-unknown-linux-gnu

# Cross-compile
cargo build --target aarch64-unknown-linux-gnu --release
</code></pre>
<h3 id="docker-builds"><a class="header" href="#docker-builds">Docker Builds</a></h3>
<pre><code class="language-dockerfile"># Multi-platform build
FROM rust:1.85 AS builder
WORKDIR /app
COPY . .
RUN cargo build --release

FROM debian:bookworm-slim
COPY --from=builder /app/target/release/ant-quic /usr/local/bin/
CMD ["ant-quic"]
</code></pre>
<pre><code class="language-bash"># Build for multiple architectures
docker buildx build --platform linux/amd64,linux/arm64 -t ant-quic .
</code></pre>
<h2 id="feature-support-by-platform"><a class="header" href="#feature-support-by-platform">Feature Support by Platform</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Linux</th><th>macOS</th><th>Windows</th><th>Android</th></tr>
</thead>
<tbody>
<tr><td>NAT Traversal</td><td>Full</td><td>Full</td><td>Full</td><td>Full</td></tr>
<tr><td>Hole Punching</td><td>Full</td><td>Full</td><td>Full</td><td>Partial</td></tr>
<tr><td>PQC</td><td>Full</td><td>Full</td><td>Full</td><td>Full</td></tr>
<tr><td>Interface Discovery</td><td>Full</td><td>Full</td><td>Full</td><td>Limited</td></tr>
<tr><td>IPv6</td><td>Full</td><td>Full</td><td>Full</td><td>Partial</td></tr>
</tbody>
</table>
</div>
<h2 id="network-interface-discovery"><a class="header" href="#network-interface-discovery">Network Interface Discovery</a></h2>
<p>ant-quic discovers local interfaces for candidate addresses.</p>
<h3 id="linux-1-1"><a class="header" href="#linux-1-1">Linux</a></h3>
<p>Uses <code>/proc/net/if_inet6</code> and <code>getifaddrs()</code>.</p>
<h3 id="macos-1-1"><a class="header" href="#macos-1-1">macOS</a></h3>
<p>Uses <code>getifaddrs()</code> and System Configuration framework.</p>
<h3 id="windows-1-1"><a class="header" href="#windows-1-1">Windows</a></h3>
<p>Uses <code>GetAdaptersAddresses()</code> Win32 API.</p>
<h3 id="android-1"><a class="header" href="#android-1">Android</a></h3>
<p>Limited to primary interface. Background discovery restricted.</p>
<h2 id="crypto-provider-support"><a class="header" href="#crypto-provider-support">Crypto Provider Support</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Provider</th><th>Linux</th><th>macOS</th><th>Windows</th><th>Android</th></tr>
</thead>
<tbody>
<tr><td>ring</td><td>Full</td><td>Full</td><td>Full</td><td>Full</td></tr>
<tr><td>aws-lc-rs</td><td>Full</td><td>Full</td><td>Full</td><td>Partial</td></tr>
</tbody>
</table>
</div>
<h3 id="recommendations"><a class="header" href="#recommendations">Recommendations</a></h3>
<ul>
<li><strong>Linux/macOS/Windows</strong>: Either provider works well</li>
<li><strong>Android</strong>: <code>ring</code> recommended (simpler build)</li>
<li><strong>ARM</strong>: <code>aws-lc-rs</code> has assembly optimizations</li>
</ul>
<h2 id="testing-on-platforms"><a class="header" href="#testing-on-platforms">Testing on Platforms</a></h2>
<h3 id="local-testing"><a class="header" href="#local-testing">Local Testing</a></h3>
<pre><code class="language-bash"># Run tests
cargo test

# Platform-specific test
cargo test --target x86_64-unknown-linux-gnu
</code></pre>
<h3 id="ci-matrix"><a class="header" href="#ci-matrix">CI Matrix</a></h3>
<pre><code class="language-yaml">jobs:
  test:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        rust: [stable, 1.85.0]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@master
        with:
          toolchain: ${{ matrix.rust }}
      - run: cargo test
</code></pre>
<h2 id="troubleshooting-platform-issues"><a class="header" href="#troubleshooting-platform-issues">Troubleshooting Platform Issues</a></h2>
<h3 id="linux-permission-denied"><a class="header" href="#linux-permission-denied">Linux: Permission Denied</a></h3>
<pre><code class="language-bash"># If bind fails on low ports
sudo setcap cap_net_bind_service=+ep ./target/release/ant-quic
</code></pre>
<h3 id="macos-network-extension"><a class="header" href="#macos-network-extension">macOS: Network Extension</a></h3>
<p>Some corporate MDM may require network extension approval.</p>
<h3 id="windows-firewall"><a class="header" href="#windows-firewall">Windows: Firewall</a></h3>
<pre><code class="language-powershell"># Check if firewall is blocking
Get-NetFirewallRule -DisplayName "ant-quic"
</code></pre>
<h3 id="android-battery-optimization"><a class="header" href="#android-battery-optimization">Android: Battery Optimization</a></h3>
<pre><code class="language-kotlin">// Request to ignore battery optimizations
val intent = Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS)
intent.data = Uri.parse("package:$packageName")
startActivity(intent)
</code></pre>
<h2 id="see-also-11"><a class="header" href="#see-also-11">See Also</a></h2>
<ul>
<li><a href="#installation-1">Installation</a></li>
<li><a href="#troubleshooting-1">Troubleshooting</a></li>
<li><a href="#performance-tuning">Performance</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h1>
<p>Common issues and solutions for ant-quic.</p>
<h2 id="connection-issues"><a class="header" href="#connection-issues">Connection Issues</a></h2>
<h3 id="cannot-connect-to-known-peers"><a class="header" href="#cannot-connect-to-known-peers">Cannot Connect to Known Peers</a></h3>
<p><strong>Symptom</strong>: <code>connect_bootstrap()</code> times out or fails.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Check network connectivity</strong>:</p>
<pre><code class="language-bash">ping quic.saorsalabs.com
nc -zvu quic.saorsalabs.com 9000
</code></pre>
</li>
<li>
<p><strong>Verify port is not blocked</strong>:</p>
<pre><code class="language-bash"># Check firewall
sudo ufw status
sudo iptables -L -n
</code></pre>
</li>
<li>
<p><strong>Try multiple known peers</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = P2pConfig::builder()
    .known_peer("peer1.example.com:9000".parse()?)
    .known_peer("peer2.example.com:9000".parse()?)
    .known_peer("peer3.example.com:9000".parse()?)
    .build()?;
<span class="boring">}</span></code></pre>
</li>
<li>
<p><strong>Increase timeout</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = P2pConfig::builder()
    .connection_timeout(Duration::from_secs(60))
    .build()?;
<span class="boring">}</span></code></pre>
</li>
</ol>
<h3 id="connection-refused"><a class="header" href="#connection-refused">Connection Refused</a></h3>
<p><strong>Symptom</strong>: Immediate connection failure.</p>
<p><strong>Causes</strong>:</p>
<ul>
<li>Target not listening on the port</li>
<li>Firewall blocking UDP</li>
<li>Wrong address/port</li>
</ul>
<p><strong>Debug</strong>:</p>
<pre><code class="language-bash">RUST_LOG=ant_quic::connection=debug cargo run
</code></pre>
<h3 id="handshake-timeout"><a class="header" href="#handshake-timeout">Handshake Timeout</a></h3>
<p><strong>Symptom</strong>: Connection starts but times out during handshake.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Allow more time for PQC handshake</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pqc = PqcConfig::builder()
    .handshake_timeout_multiplier(2.0)
    .build()?;
<span class="boring">}</span></code></pre>
</li>
<li>
<p><strong>Check MTU issues</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mtu = MtuConfig {
    initial: 1200,
    min: 1200,
    max: 1280, // Conservative
};
<span class="boring">}</span></code></pre>
</li>
</ol>
<h2 id="nat-traversal-issues"><a class="header" href="#nat-traversal-issues">NAT Traversal Issues</a></h2>
<h3 id="no-external-address-discovered-1"><a class="header" href="#no-external-address-discovered-1">No External Address Discovered</a></h3>
<p><strong>Symptom</strong>: <code>external_address()</code> returns <code>None</code>.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Ensure connected to known peer first</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>endpoint.connect_bootstrap().await?;
let addr = endpoint.external_address();
<span class="boring">}</span></code></pre>
</li>
<li>
<p><strong>Subscribe to events to see what’s happening</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut events = endpoint.subscribe();
while let Ok(event) = events.recv().await {
    match event {
        P2pEvent::AddressDiscovered { addr } =&gt; {
            println!("Discovered: {}", addr);
        }
        P2pEvent::ConnectionFailed { reason, .. } =&gt; {
            println!("Failed: {}", reason);
        }
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre>
</li>
</ol>
<h3 id="hole-punch-always-fails"><a class="header" href="#hole-punch-always-fails">Hole Punch Always Fails</a></h3>
<p><strong>Symptom</strong>: <code>HolePunchFailed</code> events for all attempts.</p>
<p><strong>Causes</strong>:</p>
<ul>
<li>Both peers behind symmetric NAT</li>
<li>Firewall blocking UDP</li>
<li>Network doesn’t support hole punching</li>
</ul>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Check NAT type</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let candidates = endpoint.get_local_candidates();
for c in candidates {
    println!("{:?}: {}", c.source, c.addr);
}
<span class="boring">}</span></code></pre>
</li>
<li>
<p><strong>Enable symmetric NAT support</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let nat = NatConfig {
    enable_symmetric_nat: true,
    hole_punch_retries: 10,
    ..Default::default()
};
<span class="boring">}</span></code></pre>
</li>
<li>
<p><strong>Use relay (if available)</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Connect via a peer with public IP
endpoint.connect_via_peer(peer_id, relay_addr).await?;
<span class="boring">}</span></code></pre>
</li>
</ol>
<h3 id="candidates-not-found"><a class="header" href="#candidates-not-found">Candidates Not Found</a></h3>
<p><strong>Symptom</strong>: <code>get_local_candidates()</code> returns empty.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Wait for discovery</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>endpoint.connect_bootstrap().await?;
tokio::time::sleep(Duration::from_secs(2)).await;
let candidates = endpoint.get_local_candidates();
<span class="boring">}</span></code></pre>
</li>
<li>
<p><strong>Increase candidate limit</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let nat = NatConfig {
    max_candidates: 20,
    discovery_timeout: Duration::from_secs(10),
    ..Default::default()
};
<span class="boring">}</span></code></pre>
</li>
</ol>
<h2 id="crypto-issues"><a class="header" href="#crypto-issues">Crypto Issues</a></h2>
<h3 id="pqc-handshake-failure"><a class="header" href="#pqc-handshake-failure">PQC Handshake Failure</a></h3>
<p><strong>Symptom</strong>: Handshake fails with crypto error.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p><strong>Check both peers support PQC</strong> (all v0.13.0+ do)</p>
</li>
<li>
<p><strong>Increase handshake timeout</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pqc = PqcConfig::builder()
    .handshake_timeout_multiplier(3.0)
    .build()?;
<span class="boring">}</span></code></pre>
</li>
<li>
<p><strong>Check MTU for large PQC keys</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mtu = MtuConfig {
    initial: 1200,
    min: 1200,
    max: 1500,
};
<span class="boring">}</span></code></pre>
</li>
</ol>
<h3 id="certificatekey-errors"><a class="header" href="#certificatekey-errors">Certificate/Key Errors</a></h3>
<p><strong>Note</strong>: ant-quic uses Raw Public Keys (RFC 7250), not X.509 certificates.</p>
<p><strong>Symptom</strong>: Key validation fails.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Verify key generation</strong>:
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ant_quic::key_utils::{generate_ed25519_keypair, derive_peer_id};

let (private, public) = generate_ed25519_keypair();
let peer_id = derive_peer_id(&amp;public);
println!("Generated: {}", peer_id.to_hex());
<span class="boring">}</span></code></pre>
</li>
</ol>
<h2 id="build-issues"><a class="header" href="#build-issues">Build Issues</a></h2>
<h3 id="crypto-provider-conflicts-1"><a class="header" href="#crypto-provider-conflicts-1">Crypto Provider Conflicts</a></h3>
<p><strong>Symptom</strong>: Multiple crypto backends error.</p>
<p><strong>Solution</strong>:</p>
<pre><code class="language-toml"># Cargo.toml - use only one
ant-quic = { version = "0.13", default-features = false, features = ["rustls-aws-lc-rs"] }
</code></pre>
<h3 id="aws-lc-build-failure"><a class="header" href="#aws-lc-build-failure">AWS-LC Build Failure</a></h3>
<p><strong>Symptom</strong>: CMake or compiler errors.</p>
<p><strong>Solution</strong>:</p>
<pre><code class="language-bash"># Install dependencies
# Ubuntu/Debian
sudo apt install build-essential cmake

# macOS
xcode-select --install
brew install cmake
</code></pre>
<h3 id="link-errors-1"><a class="header" href="#link-errors-1">Link Errors</a></h3>
<p><strong>Symptom</strong>: Undefined symbols during linking.</p>
<p><strong>Solution</strong>:</p>
<pre><code class="language-bash">cargo clean
cargo build
</code></pre>
<h2 id="logging-and-debugging"><a class="header" href="#logging-and-debugging">Logging and Debugging</a></h2>
<h3 id="enable-debug-logging"><a class="header" href="#enable-debug-logging">Enable Debug Logging</a></h3>
<pre><code class="language-bash"># Full debug
RUST_LOG=ant_quic=debug cargo run

# Specific modules
RUST_LOG=ant_quic::nat_traversal=trace cargo run
RUST_LOG=ant_quic::connection=debug cargo run
RUST_LOG=ant_quic::crypto::pqc=debug cargo run
</code></pre>
<h3 id="capture-packet-traces"><a class="header" href="#capture-packet-traces">Capture Packet Traces</a></h3>
<pre><code class="language-bash"># With tcpdump
sudo tcpdump -i any -w capture.pcap udp port 9000

# With Wireshark
# Filter: udp.port == 9000
</code></pre>
<h3 id="network-simulation-1"><a class="header" href="#network-simulation-1">Network Simulation</a></h3>
<p>Use Docker for controlled testing:</p>
<pre><code class="language-bash">cd docker/nat-test
docker-compose up
</code></pre>
<h2 id="common-error-messages"><a class="header" href="#common-error-messages">Common Error Messages</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Error</th><th>Cause</th><th>Solution</th></tr>
</thead>
<tbody>
<tr><td><code>ConnectionRefused</code></td><td>No listener at address</td><td>Verify target is running</td></tr>
<tr><td><code>TimedOut</code></td><td>Network/firewall issue</td><td>Check connectivity</td></tr>
<tr><td><code>HandshakeFailed</code></td><td>Crypto mismatch</td><td>Verify both peers are v0.13.0+</td></tr>
<tr><td><code>NoViableCandidates</code></td><td>NAT too restrictive</td><td>Enable symmetric NAT support</td></tr>
<tr><td><code>CoordinationTimeout</code></td><td>Slow coordination</td><td>Increase timeout</td></tr>
</tbody>
</table>
</div>
<h2 id="getting-help-1"><a class="header" href="#getting-help-1">Getting Help</a></h2>
<ol>
<li><strong>Enable verbose logging</strong> and capture output</li>
<li><strong>Check platform support</strong> for your OS</li>
<li><strong>File an issue</strong> at github.com/dirvine/ant-quic/issues</li>
</ol>
<p>Include:</p>
<ul>
<li>ant-quic version</li>
<li>OS and version</li>
<li>Rust version</li>
<li>Debug log output</li>
<li>Network topology (behind NAT? VPN?)</li>
</ul>
<h2 id="see-also-12"><a class="header" href="#see-also-12">See Also</a></h2>
<ul>
<li><a href="#configuration">Configuration</a> - All options</li>
<li><a href="#performance-tuning">Performance</a> - Tuning guide</li>
<li><a href="#nat-traversal">NAT Traversal</a> - How NAT traversal works</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="configuration-reference"><a class="header" href="#configuration-reference">Configuration Reference</a></h1>
<p>Complete reference for all ant-quic configuration options.</p>
<h2 id="p2pconfig-2"><a class="header" href="#p2pconfig-2">P2pConfig</a></h2>
<p>Main configuration for P2P endpoints.</p>
<h3 id="builder-methods"><a class="header" href="#builder-methods">Builder Methods</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = P2pConfig::builder()
    .bind_addr(addr)          // Local address to bind
    .known_peer(addr)         // Address to connect for discovery
    .nat(nat_config)          // NAT traversal configuration
    .pqc(pqc_config)          // Post-quantum crypto configuration
    .mtu(mtu_config)          // MTU configuration
    .max_connections(n)       // Maximum concurrent connections
    .connection_timeout(d)    // Connection establishment timeout
    .idle_timeout(d)          // Idle connection timeout
    .build()?;
<span class="boring">}</span></code></pre>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Option</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>bind_addr</code></td><td><code>SocketAddr</code></td><td><code>0.0.0.0:0</code></td><td>Local address to bind</td></tr>
<tr><td><code>known_peer</code></td><td><code>SocketAddr</code></td><td>(none)</td><td>Known peer address (can add multiple)</td></tr>
<tr><td><code>nat</code></td><td><code>NatConfig</code></td><td><code>Default</code></td><td>NAT traversal settings</td></tr>
<tr><td><code>pqc</code></td><td><code>PqcConfig</code></td><td><code>Default</code></td><td>PQC settings</td></tr>
<tr><td><code>mtu</code></td><td><code>MtuConfig</code></td><td><code>Default</code></td><td>MTU settings</td></tr>
<tr><td><code>max_connections</code></td><td><code>usize</code></td><td><code>100</code></td><td>Max concurrent connections</td></tr>
<tr><td><code>connection_timeout</code></td><td><code>Duration</code></td><td><code>30s</code></td><td>Connection timeout</td></tr>
<tr><td><code>idle_timeout</code></td><td><code>Duration</code></td><td><code>60s</code></td><td>Idle connection timeout</td></tr>
</tbody>
</table>
</div>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = P2pConfig::builder()
    .bind_addr("0.0.0.0:9000".parse()?)
    .known_peer("quic.saorsalabs.com:9000".parse()?)
    .known_peer("peer2.example.com:9000".parse()?)
    .max_connections(50)
    .connection_timeout(Duration::from_secs(45))
    .idle_timeout(Duration::from_secs(120))
    .build()?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="natconfig-2"><a class="header" href="#natconfig-2">NatConfig</a></h2>
<p>NAT traversal configuration.</p>
<h3 id="fields-4"><a class="header" href="#fields-4">Fields</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NatConfig {
    pub max_candidates: usize,
    pub coordination_timeout: Duration,
    pub discovery_timeout: Duration,
    pub enable_symmetric_nat: bool,
    pub hole_punch_retries: u32,
}
<span class="boring">}</span></code></pre>
<h3 id="options-1"><a class="header" href="#options-1">Options</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>max_candidates</code></td><td><code>usize</code></td><td><code>10</code></td><td>Maximum address candidates</td></tr>
<tr><td><code>coordination_timeout</code></td><td><code>Duration</code></td><td><code>15s</code></td><td>Hole punch coordination timeout</td></tr>
<tr><td><code>discovery_timeout</code></td><td><code>Duration</code></td><td><code>5s</code></td><td>Candidate discovery timeout</td></tr>
<tr><td><code>enable_symmetric_nat</code></td><td><code>bool</code></td><td><code>true</code></td><td>Enable port prediction</td></tr>
<tr><td><code>hole_punch_retries</code></td><td><code>u32</code></td><td><code>5</code></td><td>Number of punch attempts</td></tr>
</tbody>
</table>
</div>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let nat = NatConfig {
    max_candidates: 15,
    coordination_timeout: Duration::from_secs(20),
    discovery_timeout: Duration::from_secs(10),
    enable_symmetric_nat: true,
    hole_punch_retries: 10,
};
<span class="boring">}</span></code></pre>
<h3 id="defaults"><a class="header" href="#defaults">Defaults</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Default for NatConfig {
    fn default() -&gt; Self {
        Self {
            max_candidates: 10,
            coordination_timeout: Duration::from_secs(15),
            discovery_timeout: Duration::from_secs(5),
            enable_symmetric_nat: true,
            hole_punch_retries: 5,
        }
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="pqcconfig-2"><a class="header" href="#pqcconfig-2">PqcConfig</a></h2>
<p>Post-quantum cryptography configuration.</p>
<p><strong>Important</strong>: PQC cannot be disabled. These options tune PQC behavior.</p>
<h3 id="builder-methods-1"><a class="header" href="#builder-methods-1">Builder Methods</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pqc = PqcConfig::builder()
    .ml_kem(true)                      // Enable ML-KEM-768
    .ml_dsa(true)                      // Enable ML-DSA-65
    .memory_pool_size(10)              // Reusable buffer count
    .handshake_timeout_multiplier(1.5) // Timeout adjustment
    .build()?;
<span class="boring">}</span></code></pre>
<h3 id="options-2"><a class="header" href="#options-2">Options</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Option</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>ml_kem</code></td><td><code>bool</code></td><td><code>true</code></td><td>Enable ML-KEM-768 key exchange</td></tr>
<tr><td><code>ml_dsa</code></td><td><code>bool</code></td><td><code>true</code></td><td>Enable ML-DSA-65 signatures</td></tr>
<tr><td><code>memory_pool_size</code></td><td><code>usize</code></td><td><code>10</code></td><td>Number of reusable buffers</td></tr>
<tr><td><code>handshake_timeout_multiplier</code></td><td><code>f64</code></td><td><code>1.5</code></td><td>Timeout multiplier for PQC</td></tr>
</tbody>
</table>
</div>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pqc = PqcConfig::builder()
    .ml_kem(true)
    .ml_dsa(true)
    .memory_pool_size(20)
    .handshake_timeout_multiplier(2.0)
    .build()?;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="mtuconfig-2"><a class="header" href="#mtuconfig-2">MtuConfig</a></h2>
<p>MTU (Maximum Transmission Unit) configuration.</p>
<h3 id="fields-1-1"><a class="header" href="#fields-1-1">Fields</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MtuConfig {
    pub initial: u16,
    pub min: u16,
    pub max: u16,
}
<span class="boring">}</span></code></pre>
<h3 id="options-3"><a class="header" href="#options-3">Options</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>initial</code></td><td><code>u16</code></td><td><code>1200</code></td><td>Initial MTU for new connections</td></tr>
<tr><td><code>min</code></td><td><code>u16</code></td><td><code>1200</code></td><td>Minimum MTU (QUIC minimum)</td></tr>
<tr><td><code>max</code></td><td><code>u16</code></td><td><code>1500</code></td><td>Maximum MTU after path validation</td></tr>
</tbody>
</table>
</div>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mtu = MtuConfig {
    initial: 1200,
    min: 1200,
    max: 1500,
};
<span class="boring">}</span></code></pre>
<h3 id="considerations"><a class="header" href="#considerations">Considerations</a></h3>
<ul>
<li>PQC handshakes are larger (~8KB total)</li>
<li>Initial MTU affects handshake packet splitting</li>
<li>Conservative settings improve compatibility</li>
<li>Higher max MTU improves throughput after validation</li>
</ul>
<hr>
<h2 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment Variables</a></h2>
<p>Configuration can be influenced by environment variables:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variable</th><th>Effect</th></tr>
</thead>
<tbody>
<tr><td><code>RUST_LOG</code></td><td>Logging level (debug, info, warn, error)</td></tr>
</tbody>
</table>
</div>
<h3 id="logging-examples"><a class="header" href="#logging-examples">Logging Examples</a></h3>
<pre><code class="language-bash"># Full debug
RUST_LOG=ant_quic=debug

# Specific modules
RUST_LOG=ant_quic::nat_traversal=trace
RUST_LOG=ant_quic::crypto::pqc=debug
RUST_LOG=ant_quic::connection=info
</code></pre>
<hr>
<h2 id="complete-configuration-example"><a class="header" href="#complete-configuration-example">Complete Configuration Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ant_quic::{P2pConfig, NatConfig, PqcConfig, MtuConfig};
use std::time::Duration;

fn create_config() -&gt; anyhow::Result&lt;P2pConfig&gt; {
    // NAT traversal tuning
    let nat = NatConfig {
        max_candidates: 15,
        coordination_timeout: Duration::from_secs(20),
        discovery_timeout: Duration::from_secs(10),
        enable_symmetric_nat: true,
        hole_punch_retries: 10,
    };

    // PQC tuning
    let pqc = PqcConfig::builder()
        .ml_kem(true)
        .ml_dsa(true)
        .memory_pool_size(20)
        .handshake_timeout_multiplier(2.0)
        .build()?;

    // MTU settings
    let mtu = MtuConfig {
        initial: 1200,
        min: 1200,
        max: 1500,
    };

    // Complete config
    let config = P2pConfig::builder()
        .bind_addr("0.0.0.0:9000".parse()?)
        .known_peer("quic.saorsalabs.com:9000".parse()?)
        .known_peer("peer2.example.com:9000".parse()?)
        .known_peer("peer3.example.com:9000".parse()?)
        .nat(nat)
        .pqc(pqc)
        .mtu(mtu)
        .max_connections(100)
        .connection_timeout(Duration::from_secs(45))
        .idle_timeout(Duration::from_secs(120))
        .build()?;

    Ok(config)
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="removed-configuration-v0130"><a class="header" href="#removed-configuration-v0130">Removed Configuration (v0.13.0)</a></h2>
<p>The following options were <strong>removed</strong> in v0.13.0:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Removed</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>role</code> / <code>EndpointRole</code></td><td>All nodes are symmetric</td></tr>
<tr><td><code>bootstrap_nodes</code></td><td>Use <code>known_peer()</code> instead</td></tr>
<tr><td><code>enable_coordinator</code></td><td>All nodes can coordinate</td></tr>
<tr><td><code>PqcMode</code></td><td>PQC always enabled</td></tr>
<tr><td><code>HybridPreference</code></td><td>No mode selection</td></tr>
<tr><td><code>fallback_enabled</code></td><td>No fallback to classical</td></tr>
<tr><td><code>AuthConfig</code></td><td>Raw Public Keys only</td></tr>
</tbody>
</table>
</div>
<h3 id="migration"><a class="header" href="#migration">Migration</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// OLD (v0.12 and earlier) - DO NOT USE
// let config = QuicNodeConfig {
//     role: EndpointRole::Client,
//     bootstrap_nodes: vec![...],
//     enable_coordinator: false,
//     ...
// };

// NEW (v0.13.0+)
let config = P2pConfig::builder()
    .known_peer("peer.example.com:9000".parse()?)
    .build()?;
<span class="boring">}</span></code></pre>
<h2 id="see-also-13"><a class="header" href="#see-also-13">See Also</a></h2>
<ul>
<li><a href="#configuration">Configuration Guide</a></li>
<li><a href="#api-reference">API Reference</a></li>
<li><a href="#troubleshooting-1">Troubleshooting</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="protocol-specification"><a class="header" href="#protocol-specification">Protocol Specification</a></h1>
<p>Technical specification for ant-quic’s QUIC extensions.</p>
<h2 id="standards-compliance"><a class="header" href="#standards-compliance">Standards Compliance</a></h2>
<p>ant-quic implements or extends:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Standard</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>RFC 9000</td><td>QUIC Transport Protocol</td></tr>
<tr><td>RFC 9001</td><td>Using TLS with QUIC</td></tr>
<tr><td>RFC 7250</td><td>Raw Public Keys in TLS</td></tr>
<tr><td>draft-seemann-quic-nat-traversal-02</td><td>NAT Traversal for QUIC</td></tr>
<tr><td>draft-ietf-quic-address-discovery-00</td><td>Address Discovery</td></tr>
<tr><td>FIPS 203</td><td>ML-KEM-768</td></tr>
<tr><td>FIPS 204</td><td>ML-DSA-65</td></tr>
</tbody>
</table>
</div>
<h2 id="transport-parameters-1"><a class="header" href="#transport-parameters-1">Transport Parameters</a></h2>
<h3 id="nat-traversal-capability"><a class="header" href="#nat-traversal-capability">NAT Traversal Capability</a></h3>
<pre><code>Parameter ID: 0x3d7e9f0bca12fea6
Length: 0
Purpose: Indicates NAT traversal support
</code></pre>
<h3 id="rfc-compliant-frame-format"><a class="header" href="#rfc-compliant-frame-format">RFC-Compliant Frame Format</a></h3>
<pre><code>Parameter ID: 0x3d7e9f0bca12fea8
Length: 0
Purpose: Indicates RFC-compliant frame format
</code></pre>
<h3 id="address-discovery-configuration"><a class="header" href="#address-discovery-configuration">Address Discovery Configuration</a></h3>
<pre><code>Parameter ID: 0x9f81a176
Length: Variable
Purpose: Address discovery settings
Format:
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |  Flags (8)  | Lifetime (varint)|
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<h2 id="extension-frames-1"><a class="header" href="#extension-frames-1">Extension Frames</a></h2>
<h3 id="add_address"><a class="header" href="#add_address">ADD_ADDRESS</a></h3>
<p>Advertises address candidates to peer.</p>
<pre><code>Type: 0x3d7e90 (IPv4), 0x3d7e91 (IPv6)

Format:
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Sequence Number (i)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                       IP Address (4/16)                       +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Port (16)          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Fields:
- Sequence Number: Monotonically increasing identifier
- IP Address: 4 bytes (IPv4) or 16 bytes (IPv6)
- Port: 16-bit port number
</code></pre>
<h3 id="punch_me_now"><a class="header" href="#punch_me_now">PUNCH_ME_NOW</a></h3>
<p>Coordinates hole punching timing.</p>
<pre><code>Type: 0x3d7e92 (IPv4), 0x3d7e93 (IPv6)

Format:
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Sequence Number (i)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                     Target IP Address (4/16)                  +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Target Port (16)     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Fields:
- Sequence Number: Matches ADD_ADDRESS sequence
- Target IP Address: Address to punch toward
- Target Port: Port to punch toward
</code></pre>
<h3 id="remove_address"><a class="header" href="#remove_address">REMOVE_ADDRESS</a></h3>
<p>Removes a previously advertised address.</p>
<pre><code>Type: 0x3d7e94

Format:
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Sequence Number (i)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Fields:
- Sequence Number: Identifies the address to remove
</code></pre>
<h3 id="observed_address"><a class="header" href="#observed_address">OBSERVED_ADDRESS</a></h3>
<p>Reports observed external address to peer.</p>
<pre><code>Type: 0x9f81a6 (IPv4), 0x9f81a7 (IPv6)

Format:
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Sequence Number (i)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                    Observed IP Address (4/16)                 +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Observed Port (16)    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Fields:
- Sequence Number: Monotonically increasing
- Observed IP Address: Address seen by sender
- Observed Port: Port seen by sender
</code></pre>
<h2 id="variable-length-integer-encoding-2"><a class="header" href="#variable-length-integer-encoding-2">Variable-Length Integer Encoding</a></h2>
<p>QUIC uses variable-length integers:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Range</th><th>Prefix</th><th>Bytes</th></tr>
</thead>
<tbody>
<tr><td>0-63</td><td>00</td><td>1</td></tr>
<tr><td>0-16383</td><td>01</td><td>2</td></tr>
<tr><td>0-1073741823</td><td>10</td><td>4</td></tr>
<tr><td>0-4611686018427387903</td><td>11</td><td>8</td></tr>
</tbody>
</table>
</div>
<h2 id="handshake-protocol"><a class="header" href="#handshake-protocol">Handshake Protocol</a></h2>
<h3 id="connection-establishment-2"><a class="header" href="#connection-establishment-2">Connection Establishment</a></h3>
<pre><code>Client                                Server
   |                                     |
   |------------ Initial ----------------&gt;|
   |   + ClientHello (with X25519+ML-KEM) |
   |                                     |
   |&lt;----------- Initial ----------------|
   |   + ServerHello (with X25519+ML-KEM) |
   |   + EncryptedExtensions             |
   |   + Certificate (Raw Public Key)    |
   |   + CertificateVerify (Ed25519+ML-DSA)|
   |   + Finished                        |
   |                                     |
   |------------ Handshake -------------&gt;|
   |   + Certificate (Raw Public Key)    |
   |   + CertificateVerify (Ed25519+ML-DSA)|
   |   + Finished                        |
   |                                     |
   |&lt;========= Application Data ========&gt;|
</code></pre>
<h3 id="nat-traversal-negotiation"><a class="header" href="#nat-traversal-negotiation">NAT Traversal Negotiation</a></h3>
<p>During handshake, peers exchange transport parameters:</p>
<pre><code>Transport Parameters (Client):
  - 0x3d7e9f0bca12fea6: (NAT traversal capability)
  - 0x9f81a176: [discovery config]

Transport Parameters (Server):
  - 0x3d7e9f0bca12fea6: (NAT traversal capability)
  - 0x9f81a176: [discovery config]
</code></pre>
<h2 id="cryptographic-specifications"><a class="header" href="#cryptographic-specifications">Cryptographic Specifications</a></h2>
<h3 id="key-exchange-1"><a class="header" href="#key-exchange-1">Key Exchange</a></h3>
<ol>
<li>
<p><strong>X25519</strong>: Classical ECDH</p>
<ul>
<li>Public key: 32 bytes</li>
<li>Shared secret: 32 bytes</li>
</ul>
</li>
<li>
<p><strong>ML-KEM-768</strong>: Post-quantum KEM</p>
<ul>
<li>Public key: 1,184 bytes</li>
<li>Ciphertext: 1,088 bytes</li>
<li>Shared secret: 32 bytes</li>
</ul>
</li>
</ol>
<p>Combined shared secret:</p>
<pre><code>shared_secret = KDF(x25519_shared || ml_kem_shared)
</code></pre>
<h3 id="digital-signatures-1"><a class="header" href="#digital-signatures-1">Digital Signatures</a></h3>
<ol>
<li>
<p><strong>Ed25519</strong>: Classical signatures</p>
<ul>
<li>Public key: 32 bytes</li>
<li>Signature: 64 bytes</li>
</ul>
</li>
<li>
<p><strong>ML-DSA-65</strong>: Post-quantum signatures</p>
<ul>
<li>Public key: 1,952 bytes</li>
<li>Signature: 3,293 bytes</li>
</ul>
</li>
</ol>
<p>Combined signature:</p>
<pre><code>signature = ed25519_sig || ml_dsa_sig
</code></pre>
<h3 id="raw-public-keys-2"><a class="header" href="#raw-public-keys-2">Raw Public Keys</a></h3>
<p>Per RFC 7250:</p>
<pre><code>struct {
    SubjectPublicKeyInfo public_key;
} Certificate;
</code></pre>
<p>No certificate chain, CA, or extensions.</p>
<h2 id="address-discovery-protocol"><a class="header" href="#address-discovery-protocol">Address Discovery Protocol</a></h2>
<h3 id="discovery-flow"><a class="header" href="#discovery-flow">Discovery Flow</a></h3>
<pre><code>Connecting Node                      Known Peer
      |                                  |
      |--------- QUIC Handshake --------&gt;|
      |                                  |
      |                     [Observe source address]
      |                                  |
      |&lt;------- OBSERVED_ADDRESS --------|
      |   (addr: 203.0.113.50:45678)     |
      |                                  |
      |         [Now knows external address]
      |                                  |
</code></pre>
<h3 id="hole-punching-protocol-1"><a class="header" href="#hole-punching-protocol-1">Hole Punching Protocol</a></h3>
<pre><code>Node A                 Coordinator              Node B
   |                       |                       |
   |-- ADD_ADDRESS -------&gt;|                       |
   |                       |&lt;------ ADD_ADDRESS ---|
   |                       |                       |
   |                   [Exchange candidates]       |
   |                       |                       |
   |&lt;-- PUNCH_ME_NOW ------|                       |
   |                       |------- PUNCH_ME_NOW -&gt;|
   |                       |                       |
   |============= Simultaneous UDP ===============&gt;|
   |&lt;============ Simultaneous UDP ================|
   |                       |                       |
   |&lt;=== Direct QUIC Connection Established =====&gt;|
</code></pre>
<h2 id="security-considerations-1"><a class="header" href="#security-considerations-1">Security Considerations</a></h2>
<h3 id="frame-authentication"><a class="header" href="#frame-authentication">Frame Authentication</a></h3>
<p>All extension frames are:</p>
<ol>
<li>Sent over authenticated QUIC connections</li>
<li>Encrypted with TLS 1.3 (AEAD)</li>
<li>Bound to the connection ID</li>
</ol>
<h3 id="address-validation"><a class="header" href="#address-validation">Address Validation</a></h3>
<p>Receivers MUST validate:</p>
<ol>
<li>Sequence numbers are monotonic</li>
<li>Addresses are valid (no multicast, etc.)</li>
<li>Rate limits are respected</li>
</ol>
<h3 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h3>
<p>Implementations SHOULD limit:</p>
<ul>
<li>ADD_ADDRESS: 10 per second</li>
<li>PUNCH_ME_NOW: 5 per second</li>
<li>OBSERVED_ADDRESS: 2 per second</li>
</ul>
<h2 id="references-3"><a class="header" href="#references-3">References</a></h2>
<ul>
<li><a href="https://www.rfc-editor.org/rfc/rfc9000">RFC 9000</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc7250">RFC 7250</a></li>
<li><a href="../../rfcs/draft-seemann-quic-nat-traversal-02.txt">draft-seemann-quic-nat-traversal-02</a></li>
<li><a href="../../rfcs/draft-ietf-quic-address-discovery-00.txt">draft-ietf-quic-address-discovery-00</a></li>
<li><a href="../../rfcs/fips-203-ml-kem.pdf">FIPS 203</a></li>
<li><a href="../../rfcs/fips-204-ml-dsa.pdf">FIPS 204</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p>Terms and concepts used in ant-quic documentation.</p>
<h2 id="a"><a class="header" href="#a">A</a></h2>
<h3 id="add_address-1"><a class="header" href="#add_address-1">ADD_ADDRESS</a></h3>
<p>A QUIC extension frame (type 0x3d7e90/0x3d7e91) used to advertise candidate addresses during NAT traversal.</p>
<h3 id="address-discovery-5"><a class="header" href="#address-discovery-5">Address Discovery</a></h3>
<p>The process of learning your external IP address and port as seen by other peers. Implemented via OBSERVED_ADDRESS frames per draft-ietf-quic-address-discovery-00.</p>
<h2 id="c"><a class="header" href="#c">C</a></h2>
<h3 id="candidate-address"><a class="header" href="#candidate-address">Candidate Address</a></h3>
<p>An address that might be used to reach a peer. Candidates can be:</p>
<ul>
<li><strong>Local</strong>: Interface addresses</li>
<li><strong>Observed</strong>: Discovered via OBSERVED_ADDRESS</li>
<li><strong>Predicted</strong>: Symmetric NAT port predictions</li>
</ul>
<h3 id="cgnat"><a class="header" href="#cgnat">CGNAT</a></h3>
<p>Carrier Grade NAT. ISP-level NAT using the 100.64.0.0/10 address space. Increasingly common due to IPv4 exhaustion.</p>
<h3 id="connection-1"><a class="header" href="#connection-1">Connection</a></h3>
<p>A QUIC connection between two peers, providing encrypted bidirectional communication with stream multiplexing.</p>
<h2 id="d"><a class="header" href="#d">D</a></h2>
<h3 id="draft-ietf-quic-address-discovery-00"><a class="header" href="#draft-ietf-quic-address-discovery-00">draft-ietf-quic-address-discovery-00</a></h3>
<p>IETF draft specifying how QUIC peers can discover their external addresses through OBSERVED_ADDRESS frames.</p>
<h3 id="draft-seemann-quic-nat-traversal-02"><a class="header" href="#draft-seemann-quic-nat-traversal-02">draft-seemann-quic-nat-traversal-02</a></h3>
<p>IETF draft specifying QUIC-native NAT traversal using ADD_ADDRESS and PUNCH_ME_NOW frames.</p>
<h2 id="e"><a class="header" href="#e">E</a></h2>
<h3 id="ed25519"><a class="header" href="#ed25519">Ed25519</a></h3>
<p>An elliptic curve digital signature algorithm used for peer identity in ant-quic.</p>
<h3 id="endpoint"><a class="header" href="#endpoint">Endpoint</a></h3>
<p>A QUIC endpoint that can both initiate and accept connections. In ant-quic, all endpoints are symmetric.</p>
<h2 id="f"><a class="header" href="#f">F</a></h2>
<h3 id="fips-203"><a class="header" href="#fips-203">FIPS 203</a></h3>
<p>NIST standard for ML-KEM (Module-Lattice-based Key Encapsulation Mechanism).</p>
<h3 id="fips-204"><a class="header" href="#fips-204">FIPS 204</a></h3>
<p>NIST standard for ML-DSA (Module-Lattice-based Digital Signature Algorithm).</p>
<h3 id="forward-secrecy-1"><a class="header" href="#forward-secrecy-1">Forward Secrecy</a></h3>
<p>A property where compromise of long-term keys doesn’t compromise past session keys. ant-quic achieves this through ephemeral key exchange.</p>
<h3 id="full-cone-nat"><a class="header" href="#full-cone-nat">Full Cone NAT</a></h3>
<p>The most permissive NAT type. Once a mapping is created, any external host can send packets to the internal host.</p>
<h2 id="h"><a class="header" href="#h">H</a></h2>
<h3 id="hole-punching"><a class="header" href="#hole-punching">Hole Punching</a></h3>
<p>A technique for establishing direct connections through NAT by having both peers send packets simultaneously, creating NAT mappings that allow the other’s packets through.</p>
<h3 id="hybrid-cryptography"><a class="header" href="#hybrid-cryptography">Hybrid Cryptography</a></h3>
<p>Using both classical and post-quantum algorithms together. An attacker must break both to compromise security.</p>
<h2 id="k"><a class="header" href="#k">K</a></h2>
<h3 id="known-peer"><a class="header" href="#known-peer">Known Peer</a></h3>
<p>An address to connect to first for address discovery. Replaces the outdated term “bootstrap node” - known peers are just regular peers with known addresses.</p>
<h2 id="m"><a class="header" href="#m">M</a></h2>
<h3 id="ml-dsa-65"><a class="header" href="#ml-dsa-65">ML-DSA-65</a></h3>
<p>Module-Lattice-based Digital Signature Algorithm at NIST security level 3. Used for post-quantum authentication in ant-quic.</p>
<h3 id="ml-kem-768"><a class="header" href="#ml-kem-768">ML-KEM-768</a></h3>
<p>Module-Lattice-based Key Encapsulation Mechanism at NIST security level 3. Used for post-quantum key exchange in ant-quic.</p>
<h3 id="mtu"><a class="header" href="#mtu">MTU</a></h3>
<p>Maximum Transmission Unit. The largest packet size that can be sent. PQC increases handshake sizes, affecting MTU requirements.</p>
<h2 id="n"><a class="header" href="#n">N</a></h2>
<h3 id="nat"><a class="header" href="#nat">NAT</a></h3>
<p>Network Address Translation. A technique for mapping private IP addresses to public ones. NAT traversal is needed for P2P connectivity.</p>
<h3 id="natconfig-3"><a class="header" href="#natconfig-3">NatConfig</a></h3>
<p>Configuration struct for NAT traversal parameters in ant-quic.</p>
<h2 id="o"><a class="header" href="#o">O</a></h2>
<h3 id="observed_address-1"><a class="header" href="#observed_address-1">OBSERVED_ADDRESS</a></h3>
<p>A QUIC extension frame (type 0x9f81a6/0x9f81a7) that reports the external address observed by the peer.</p>
<h2 id="p"><a class="header" href="#p">P</a></h2>
<h3 id="p2pconfig-3"><a class="header" href="#p2pconfig-3">P2pConfig</a></h3>
<p>The main configuration struct for ant-quic P2P endpoints.</p>
<h3 id="p2pendpoint-1"><a class="header" href="#p2pendpoint-1">P2pEndpoint</a></h3>
<p>The primary API for ant-quic. Represents a symmetric P2P node that can connect to and accept connections from peers.</p>
<h3 id="p2pevent-2"><a class="header" href="#p2pevent-2">P2pEvent</a></h3>
<p>Events emitted by the endpoint, including connection events, address discovery, and NAT traversal status.</p>
<h3 id="peer-id"><a class="header" href="#peer-id">Peer ID</a></h3>
<p>A unique identifier for a peer, derived from their Ed25519 public key.</p>
<h3 id="port-restricted-nat"><a class="header" href="#port-restricted-nat">Port Restricted NAT</a></h3>
<p>A NAT type where external hosts can only send packets if the internal host previously sent to that host and port.</p>
<h3 id="pqc"><a class="header" href="#pqc">PQC</a></h3>
<p>Post-Quantum Cryptography. Cryptographic algorithms designed to resist attacks by quantum computers.</p>
<h3 id="pqcconfig-3"><a class="header" href="#pqcconfig-3">PqcConfig</a></h3>
<p>Configuration struct for PQC parameters. Note: PQC cannot be disabled in v0.13.0+.</p>
<h3 id="punch_me_now-1"><a class="header" href="#punch_me_now-1">PUNCH_ME_NOW</a></h3>
<p>A QUIC extension frame (type 0x3d7e92/0x3d7e93) used to coordinate simultaneous hole punching.</p>
<h2 id="q"><a class="header" href="#q">Q</a></h2>
<h3 id="quic"><a class="header" href="#quic">QUIC</a></h3>
<p>A modern transport protocol providing multiplexed, encrypted connections over UDP. ant-quic extends QUIC with NAT traversal capabilities.</p>
<h2 id="r"><a class="header" href="#r">R</a></h2>
<h3 id="raw-public-keys-3"><a class="header" href="#raw-public-keys-3">Raw Public Keys</a></h3>
<p>A TLS extension (RFC 7250) allowing authentication using bare public keys instead of X.509 certificates.</p>
<h3 id="rfc-7250"><a class="header" href="#rfc-7250">RFC 7250</a></h3>
<p>IETF RFC specifying Raw Public Keys for TLS authentication.</p>
<h3 id="rfc-9000"><a class="header" href="#rfc-9000">RFC 9000</a></h3>
<p>IETF RFC specifying the QUIC transport protocol.</p>
<h2 id="s"><a class="header" href="#s">S</a></h2>
<h3 id="stream"><a class="header" href="#stream">Stream</a></h3>
<p>A bidirectional or unidirectional data channel within a QUIC connection. Multiple streams can be multiplexed on one connection.</p>
<h3 id="symmetric-nat-1"><a class="header" href="#symmetric-nat-1">Symmetric NAT</a></h3>
<p>The most restrictive NAT type. Uses different external ports for different destinations, making direct connections difficult.</p>
<h3 id="symmetric-p2p"><a class="header" href="#symmetric-p2p">Symmetric P2P</a></h3>
<p>ant-quic’s architectural model where all nodes have identical capabilities - no special roles like “client”, “server”, or “bootstrap”.</p>
<h2 id="t"><a class="header" href="#t">T</a></h2>
<h3 id="transport-parameters-2"><a class="header" href="#transport-parameters-2">Transport Parameters</a></h3>
<p>QUIC parameters exchanged during connection establishment. ant-quic uses custom transport parameters for NAT traversal negotiation.</p>
<h2 id="x"><a class="header" href="#x">X</a></h2>
<h3 id="x25519"><a class="header" href="#x25519">X25519</a></h3>
<p>An elliptic curve Diffie-Hellman function used for classical key exchange in ant-quic’s hybrid scheme.</p>
<hr>
<h2 id="removed-terms-v0130"><a class="header" href="#removed-terms-v0130">Removed Terms (v0.13.0)</a></h2>
<p>These terms are <strong>no longer used</strong> in ant-quic v0.13.0+:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Removed Term</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Bootstrap Node</td><td>All nodes are symmetric - use “known peer” instead</td></tr>
<tr><td>Client Role</td><td>No roles in symmetric P2P</td></tr>
<tr><td>Server Role</td><td>No roles in symmetric P2P</td></tr>
<tr><td>Coordinator</td><td>All nodes can coordinate</td></tr>
<tr><td>EndpointRole</td><td>Removed enum - all nodes symmetric</td></tr>
<tr><td>PqcMode</td><td>Removed - PQC always enabled</td></tr>
<tr><td>HybridPreference</td><td>Removed - no mode selection</td></tr>
<tr><td>Classical-Only</td><td>Not available - PQC always on</td></tr>
</tbody>
</table>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
